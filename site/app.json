[{"name":"server.R","content":"library(shiny)\nlibrary(ggiraph)\n\nserver <- function(input, output, session) {\n\n  ## Set Selector Choices based on column names\n\n\n  dataset <- reactiveVal(value = iris)\n\n  observeEvent(dataset() , {\n    updateSelectInput(\n      session = session,\n      inputId = \"in_sel_id\",\n      choices = c(\"\", colnames(dataset())),\n      selected = \"\"\n    )\n\n    updateSelectInput(\n      session = session,\n      inputId = \"in_sel_sort_col\",\n      choices = c(\"Column to Sort By\"= \"\", colnames(dataset())),\n      selected = \"\",\n    )\n\n  })\n\n\n\n  # Reactive expression to load data if user provides file. Defaults to iris if none provided.\n  observeEvent(input$in_file_dataset, {\n\n    tryCatch(\n      expr = {\n        data = rio::import(input$in_file_dataset$datapath)\n      },\n      error = function(err){\n        shinyWidgets::sendSweetAlert(session = session, title = \"Failed to import file\", text =  err2html(err))\n        validate(\"Failed to import file\")\n      },\n      warning = function(warn){\n        shinyWidgets::sendSweetAlert(session = session, title = \"Failed to Generate GG1D Plot\", text =  err2html(warn))\n        validate(\"Failed to import file\")\n      })\n\n      dataset(data)\n    })\n\n  output$out_plot_widget <- ggiraph::renderGirafe({\n    data <- req(dataset())\n\n    # Build gg1d_options from user input\n    opts <- gg1d_options(\n      show_legend = input$in_show_legend,\n      show_legend_titles = input$in_show_legend_titles,\n      legend_position = input$in_legend_position,\n      legend_title_position = input$in_legend_title_position,\n      legend_nrow = input$in_legend_nrow,\n      # We leave legend_ncol as NULL if not specified.\n      # user can add another input if needed.\n      legend_key_size = input$in_legend_key_size,\n      beautify_text = input$in_beautify_text,\n      numeric_plot_type = input$in_numeric_plot_type,\n      y_axis_position = input$in_y_axis_position,\n      width = input$in_width,\n      interactive_svg_width = input$in_svg_width,\n      interactive_svg_height = input$in_svg_height,\n      relative_height_numeric = input$in_relative_height_numeric,\n      colours_default = c(\n        input$in_default_colour_1,\n        input$in_default_colour_2,\n        input$in_default_colour_3,\n        input$in_default_colour_4,\n        input$in_default_colour_5,\n        input$in_default_colour_6,\n        input$in_default_colour_7\n        ),\n      colours_default_logical = c(\n        \"TRUE\" = input$in_default_logical_colour_true,\n        \"FALSE\" = input$in_default_logical_colour_false\n        )\n      # Add other gg1d_options parameters as needed\n    )\n\n    # Now call gg1d with user-specified parameters\n    tryCatch(\n      expr = {\n        gg1d(\n          data = data,\n          col_id = if(nchar(input$in_sel_id) == 0) NULL else input$in_sel_id,\n          col_sort = input$in_sel_sort_col,\n          order_matches_sort = input$in_order_matches_sort,\n          maxlevels = input$in_maxlevels,\n          verbose = 1,\n          drop_unused_id_levels = FALSE,\n          palettes = NULL,\n          sort_type = input$in_sel_sort_type,\n          desc = input$in_desc,\n          limit_plots = TRUE,\n          max_plottable_cols = input$in_max_plottable_cols,\n          cols_to_plot = NULL,\n          tooltip_column_suffix = \"_tooltip\",\n          ignore_column_regex = if(nchar(input$in_ignore_regex) > 0) input$in_ignore_regex else NULL,\n          convert_binary_numeric_to_factor = input$in_convert_binary_numeric,\n          options = opts\n        )\n      },\n      error = function(err){\n        shinyWidgets::sendSweetAlert(session = session, title = \"Failed to Generate GG1D Plot\", text =  err2html(err))\n        validate(\"Failed to Generate GG1D plot\")\n      },\n      warning = function(warn){\n        shinyWidgets::sendSweetAlert(session = session, title = \"Failed to Generate GG1D Plot\", text =  err2html(warn))\n        validate(\"Failed to Generate GG1D plot\")\n      }\n    )\n  })\n\n  # Render UI palettes\n  # output$out_ui_palettes <- renderUI({\n  #   data <- req(dataset())\n  #   col_is_categorical <- vapply(data, function(x) { is.character(x) || is.factor(x) }, logical(1))\n  #   categorical_col_names <- colnames(data)[col_is_categorical]\n  #\n  #   pickers_list <- lapply(categorical_col_names, function(colname) {\n  #     categorical_col_values <- unique(data[[colname]])\n  #     card(min_height = \"300px\",\n  #       card_header(colname),\n  #       div(\n  #         style = \"display:flex; flex-wrap: wrap; gap: 10px;\",\n  #         lapply(categorical_col_values, function(level) {\n  #           colourpicker::colourInput(\n  #             inputId = paste0(\"palette_\", colname, \"_\", level),\n  #             label = level,\n  #             value = \"#000000\"\n  #           )\n  #         })\n  #       )\n  #     )\n  #   })\n  #\n  #   do.call(tagList, pickers_list)\n  # })\n\n\n}\n","type":"text"},{"name":"ui.R","content":"library(shiny)\nlibrary(bslib)\nlibrary(ggplot2)\nlibrary(rio)\nlibrary(shinycssloaders)\nlibrary(htmlwidgets)\n\n# Source Assertions\nsource('assertions/assert.R')\nsource('assertions/assert_class.R')\nsource('assertions/is_comparisons.R')\nsource('assertions/is_functions.R')\nsource('assertions/utils.R')\nsource('assertions/assert_create.R')\nsource('assertions/assert_type.R')\nsource('assertions/assert_compare.R')\nsource('assertions/assert_dataframe.R')\nsource('assertions/assert_files.R')\nsource('assertions/assert_functions.R')\nsource('assertions/set_operations.R')\nsource('assertions/assert_includes.R')\nsource('assertions/assert_length.R')\nsource('assertions/assert_names.R')\nsource('assertions/assert_null.R')\nsource('assertions/assert_numerical.R')\nsource('assertions/assert_set.R')\nsource('assertions/coverage_testing.R')\nsource('assertions/export_testing.R')\nsource('assertions/has.R')\n# files_to_source <- list.files(path = \"assertions\", pattern = \"\\\\.R$\", full.names = TRUE)\n# sapply(files_to_source, source)\nsource(\"utils.R\")\nsource(\"gg1d/data.R\")\nsource(\"gg1d/gg1d.R\")\nsource(\"gg1d/gg1d_options.R\")\n\n\nui <- page_sidebar(\n  title = \"ggNd\",\n  theme = bs_theme(bootswatch = \"bootstrap\"),\n  sidebar = sidebar(width = \"300px\",\n    title = \"Visualisation Options\",\n    ## gg1d Parameters\n    # Output(\"out_sel_id\"),\n    # Output(\"out_sel_sort_col\"),\n\n\n    bslib::card(\n      card_header(\"Sorting\"),\n      selectizeInput(\"in_sel_sort_col\", label = \"Sort By\", choices = NULL, multiple = TRUE, selected = NULL),\n      selectInput(\"in_sel_sort_type\",\n                  label = \"Sort Type\",\n                  choices = c(\"frequency\", \"alphabetical\"), multiple = FALSE, selected = \"frequency\"\n      ),\n      checkboxInput(\"in_desc\", label = \"Descending\", value = TRUE),\n      checkboxInput(\"in_order_matches_sort\", \"Match Column Order to Sort?\", value = TRUE)\n    ),\n\n    bslib::card(\n      card_header(\"Size\"),\n      # Interactivity size\n      numericInput(\"in_svg_width\", \"Interactive SVG Width\", value = 16, min = 1),\n      numericInput(\"in_svg_height\", \"Interactive SVG Height\", value = 5, min = 1)\n    ),\n\n    bslib::card(\n      card_header(\"Main Plot\"),\n      selectInput(\"in_numeric_plot_type\", \"Numeric Plot Type\",\n                  choices = c(\"bar\", \"heatmap\"), selected = \"bar\"\n      ),\n      numericInput(\"in_relative_height_numeric\", \"Barplot Height Multiplier\", value = 2, min = 1, max = 10),\n      selectInput(\"in_y_axis_position\", \"Y Axis Position\", choices = c(\"left\", \"right\"), selected = \"left\"),\n      numericInput(\"in_width\", \"Width\", value = 0.9, min = 0.1, max = 1),\n    ),\n\n\n    bslib::card(\n      card_header(\"Columns to Plot\"),\n      textInput(\"in_ignore_regex\", \"Ignore Column Regex\", value = \"_ignore$\"),\n    ),\n\n    bslib::card(\n      card_header(\"Legend\"),\n      checkboxInput(\"in_show_legend\", \"Show Legend\", value = TRUE),\n      checkboxInput(\"in_show_legend_titles\", \"Show Legend Titles\", value = FALSE),\n      selectInput(\"in_legend_position\", \"Legend Position\",\n                  choices = c(\"right\", \"left\", \"bottom\", \"top\"), selected = \"right\"\n      ),\n      selectInput(\"in_legend_title_position\", \"Legend Title Position\",\n                  choices = c(\"top\", \"bottom\", \"left\", \"right\"), selected = \"top\"\n      ),\n      numericInput(\"in_legend_nrow\", \"Legend Nrow\", value = 1, min = 1),\n      # numericInput(\"in_legend_nrow\", \"Legend Nrow\", value = 3, min = 1),\n      numericInput(\"in_legend_key_size\", \"Legend Key Size\", value = 0.3, min = 0.1),\n    ),\n\n    bslib::card(\n      card_header(\"Data Conversion\"),\n      checkboxInput(\"in_convert_binary_numeric\", \"Autoconversion\", value = TRUE),\n      checkboxInput(\"in_beautify_text\", \"Beautify Text\", value = TRUE),\n    ),\n\n\n    bslib::card(\n      card_header(\"Other\"),\n      numericInput(\"in_maxlevels\", \"Max Levels\", value = 6, min = 1),\n      numericInput(\"in_max_plottable_cols\", \"Max Plottable Columns\", value = 15, min = 1),\n      selectInput(\"in_sel_id\", label = \"Identifier\", choices = NULL, multiple = FALSE, selected = \"\"),\n    ),\n\n    bslib::card(\n      card_header(\"Other\"),\n      numericInput(\"in_maxlevels\", \"Max Levels\", value = 6, min = 1),\n      numericInput(\"in_max_plottable_cols\", \"Max Plottable Columns\", value = 15, min = 1),\n      selectInput(\"in_sel_id\", label = \"Identifier\", choices = NULL, multiple = FALSE, selected = \"\"),\n    ),\n\n    # Colours (options)\n    bslib::card(\n      card_header(\"Default Colours (categorical)\"),\n      colourpicker::colourInput(inputId = \"in_default_colour_1\", value = \"#66C2A5\", label = \"Colour 1\"),\n      colourpicker::colourInput(inputId = \"in_default_colour_2\", value = \"#FC8D62\", label = \"Colour 2\"),\n      colourpicker::colourInput(inputId = \"in_default_colour_3\", value = \"#8DA0CB\", label = \"Colour 3\"),\n      colourpicker::colourInput(inputId = \"in_default_colour_4\", value = \"#E78AC3\", label = \"Colour 4\"),\n      colourpicker::colourInput(inputId = \"in_default_colour_5\", value = \"#A6D854\", label = \"Colour 5\"),\n      colourpicker::colourInput(inputId = \"in_default_colour_6\", value = \"#FFD92F\", label = \"Colour 6\"),\n      colourpicker::colourInput(inputId = \"in_default_colour_7\", value = \"#E5C494\", label = \"Colour 7\"),\n    ),\n\n    bslib::card(\n      card_header(\"Default Colours (logical)\"),\n      colourpicker::colourInput(inputId = \"in_default_logical_colour_true\", value = \"#648fff\", label = \"TRUE\"),\n      colourpicker::colourInput(inputId = \"in_default_logical_colour_false\", value = \"#dc267f\", label = \"FALSE\"),\n    ),\n\n\n  ),\n\n  ## File Import\n  card(\n    min_height = \"120px\",\n    max_height = \"120px\",\n    card_header(\"Import your file (TSV, CSV, or XLSX)\"),\n    card_body(\n      fileInput(inputId = \"in_file_dataset\", label = NULL, multiple = FALSE, width = \"100%\")\n    )\n  ),\n\n  ## gg1d plot\n  card(\n    min_height = \"500px\",\n    max_height = \"600px\",\n    card_header(\"Visualisation (gg1d)\"),\n    card_body(\n      withSpinner(\n        ggiraph::girafeOutput(\"out_plot_widget\", width = \"95%\")\n      )\n    )\n  ),\n#\n#   # Colours\n#   bslib::card(\n#     # max_height =  \"300px\",\n#     card_header(\"Palettes\"),\n#     wellPanel(\"Default palettes can be set using the sidebar panel. Use these settings to colour specific columns independently of the others\"),\n#     uiOutput(\"out_ui_palettes\",fill =  bslib::as_fill_carrier())\n#     # selectInput(inputId = \"in_select_cols_for_palettes\", label = \"Columns requiring custom palette\", choices = c(), selected = c(), multiple = TRUE)\n#   )\n\n)\n","type":"text"},{"name":"README.md","content":"\n# ggnd\n\n<!-- badges: start -->\n<!-- badges: end -->\n\nA shiny app and web-assembly compiled interface to gg1d.\n\n","type":"text"},{"name":"assertions/assert.R","content":"#' Assert that conditions are met\n#'\n#' @param ... a list of conditions to check\n#' @param msg A character string containing the error message to display if any of the conditions are not met.\n#' The string can include the placeholder \\{failed_expressions\\} to insert a list of the failed expressions. The string can also include \\{?s\\} and \\{?is/are\\} to insert the correct pluralization for the list of failed expressions.\n#' @inheritParams common_roxygen_params\n#'\n#' @return invisible(TRUE) if all conditions are met, otherwise aborts with the error message specified by msg\n#'\n#' @examples\n#' try({\n#' assert(1 == 1) # Passes\n#' assert(2 == 2, 3 == 3) # Passes\n#' assert(2 == 1, 3 == 3) # Throws default error\n#' assert(2 == 1, 3 == 3, msg = \"Custom error message\") # Throws custom error\n#' })\n#'\n#' @concept assert_create\n#' @export\nassert <- function(..., msg = NULL, call = rlang::caller_env()) {\n  all_expressions_list <- eval(substitute(alist(...)))\n  all_expressions_char <- sapply(all_expressions_list, FUN = deparse)\n\n  conditions <- list(...)\n  failed_expressions <- all_expressions_char[vapply(conditions, function(x) !isTRUE(x), logical(1))]\n\n  if (length(failed_expressions) > 0) {\n    if (is.null(msg)) {\n      msg <- c(\"The following assertions failed:\", format_as_bullets(format_inline(failed_expressions, 'code'), \"x\"))\n    }\n    cli::cli_abort(msg, call = call, .envir = call)\n  }\n  invisible(TRUE)\n}\n","type":"text"},{"name":"assertions/assert_class.R","content":[],"type":"text"},{"name":"assertions/assert_compare.R","content":"#' Assert input is greater than a specified minimum value\n#'\n#' Assert all elements in a numeric vector/matrix are above some minimum value.\n#'\n#' @include assert_create.R\n#' @include assert_type.R\n#' @include is_functions.R\n#' @include is_comparisons.R\n#' @param x An object to check\n#' @param minimum The minimum value to compare against (number)\n#' @param msg A character string containing the error message to display if `x` is not greater than the specified minimum value (string)\n#' @inheritParams common_roxygen_params\n#'\n#' @return invisible(TRUE) if `x` is greater than the specified minimum value, otherwise aborts with the error message specified by `msg`\n#'\n#' @examples\n#' try({\n#' assert_all_greater_than(3, 2) # Passes\n#' assert_all_greater_than(c(2,3,4), 1) # Passes\n#' assert_all_greater_than(c(2,3,4), 2) # Passes\n#' assert_all_greater_than(c(2,3,1), 3) # Throws default error\n#' assert_all_greater_than(c(2,3,1), 3, msg = \"custom error message\") # Throws custom error\n#' })\n#'\n#' @concept assert_comparison\n#' @export\nassert_all_greater_than <- assert_create_chain(\n  assert_numeric,\n  assert_create(\n    is_greater_than,\n    default_error_msg = \"{.strong {arg_name}} must {ifelse(length(arg_value) > 1, 'all ', '')}be {.strong greater than} `{.strong {minimum}}`.\"\n  )\n)\n\n#' Assert input is greater than some minimum value\n#'\n#' Assert a number is greater than a specified minimum value.\n#' To check all numbers in a vector / matrix are above a minimum value, see [assert_all_greater_than()]\n#'\n#' @include assert_create.R\n#' @include assert_type.R\n#' @include is_functions.R\n#' @include is_comparisons.R\n#' @param x An object to check\n#' @param minimum The minimum value to compare against (number)\n#' @param msg A character string containing the error message to display if `x` is not greater than the specified minimum value (string)\n#' @inheritParams common_roxygen_params\n#'\n#' @return invisible(TRUE) if `x` is greater than the specified minimum value, otherwise aborts with the error message specified by `msg`\n#'\n#' @examples\n#' try({\n#' assert_greater_than(3, 2) # Passes\n#' assert_greater_than(3, 2) # Passes\n#' assert_greater_than(c(2,3,4), 1) # Throws error (Must be a number)\n#' assert_greater_than('A', 1) # Throws error (Must be a number)\n#' assert_greater_than(2, 3, msg = \"custom error message\") # Throws custom error\n#' })\n#'\n#' @concept assert_comparison\n#' @export\nassert_greater_than <- assert_create_chain(\n  assert_number,\n  assert_all_greater_than\n)\n\n#' Assert input is greater than or equal to a specified minimum value\n#'\n#' Assert all elements in a numeric vector/matrix are above some minimum value.\n#'\n#' @param x An object to check\n#' @param minimum The minimum value to compare against\n#' @param msg A character string containing the error message to display if `x` is not greater than or equal to the specified minimum value (string)\n#' @inheritParams common_roxygen_params\n#'\n#' @return invisible(TRUE) if `x` is greater than or equal to the specified minimum value, otherwise aborts with the error message specified by `msg`\n#'\n#' @examples\n#' try({\n#' assert_greater_than_or_equal_to(3, 2) # Passes\n#' assert_greater_than_or_equal_to(c(3, 4, 5), 2) # Passes\n#' assert_greater_than_or_equal_to(2, 3) # Throws error\n#' })\n#' @export\nassert_all_greater_than_or_equal_to <- assert_create_chain(\n  assert_numeric,\n  assert_create(\n    is_greater_than_or_equal_to,\n    default_error_msg = \"{.strong {arg_name}} must {ifelse(length(arg_value) > 1, 'all ', '')}be {.strong greater than or equal to} `{.strong {minimum}}`.\"\n  )\n)\n\n#' Assert input is greater than or equal to a specified minimum value\n#'\n#' Assert all elements in a numeric vector/matrix are above or equal to some minimum value.\n#' For vectorized version see [assert_all_greater_than_or_equal_to()]\n#'\n#' @param x An object to check\n#' @param minimum The minimum value to compare against\n#' @param msg A character string containing the error message to display if `x` is not greater than or equal to the specified minimum value (string)\n#' @inheritParams common_roxygen_params\n#'\n#' @return invisible(TRUE) if `x` is greater than or equal to the specified minimum value, otherwise aborts with the error message specified by `msg`\n#'\n#' @examples\n#' try({\n#' assert_greater_than_or_equal_to(3, 2) # Passes\n#' assert_greater_than_or_equal_to(c(3, 4, 5), 2) # Throws error\n#' assert_greater_than_or_equal_to(2, 3) # Throws error\n#' })\n#' @export\nassert_greater_than_or_equal_to <- assert_create_chain(\n  assert_number,\n  assert_all_greater_than_or_equal_to\n)\n\n#' Assert that the input object is identical to a specified value\n#'\n#' @param x An object to check\n#' @param y The value to compare against\n#' @param msg A character string containing the error message to display if `x` is not identical to the specified value\n#' @inheritParams common_roxygen_params\n#'\n#' @return invisible(TRUE) if `x` is identical to the specified value, otherwise aborts with the error message specified by `msg`\n#'\n#' @examples\n#' try({\n#' assert_identical(3, 3) # Passes\n#' assert_identical(c(3, 3, 3), 3) # Throws error\n#' assert_identical(2, 3) # Throws error\n#' })\n#' @export\nassert_identical <- assert_create(is_identical, default_error_msg = \"{.strong {arg_name}} must be identical to {.strong {deparse(substitute(y))}}\")\n\n\n#' Assert that the input objects are equal\n#'\n#' Is `x` equal to `y`. powered by the [all.equal()] function.\n#'\n#' @param x An object to check\n#' @param y The value to compare against\n#' @param msg A character string containing the error message to display if `x` is not equal to `y`\n#' @inheritParams common_roxygen_params\n#' @inheritParams is_equal\n#' @return invisible(TRUE) if `x` is equal to the specified value, otherwise aborts with the error message specified by `msg`\n#'\n#' @examples\n#' try({\n#' assert_equal(3, 3) # Passes\n#' assert_equal(c(3, 3, 3), 3, ) # Fails\n#' assert_equal(2, 3) # Throws error\n#' })\n#' @export\nassert_equal <- assert_create(is_equal, default_error_msg = \"{.strong {arg_name}} must be equal to {.strong {deparse(substitute(y))}}\")\n\n\n\n# #' Assert that the input have the same type are equal\n# #'\n# #' Assert `x` is the same type as `y`. powered by the [is_same_type()] function.\n# #'\n# #' @param x First object to compare\n# #' @param y Second object to compare\n# #' @param msg A character string containing the error message to display if `x` is not the same type as `y`\n# #' @inheritParams common_roxygen_params\n# #' @inheritParams is_same_type\n# #' @return invisible(TRUE) if `x` is equal to the specified value, otherwise aborts with the error message specified by `msg`\n# #'\n# #' @examples\n# #' try({\n# #' assert_type_identical(c(3, 3, 3), 19) # Passes\n# #' assert_type_identical(c(3, 3, 3), \"bob\") # Throws error\n# #' })\n# #' @export\n#assert_type_identical <- assert_create(is_same_type, \"{.strong {arg_name}} ({.strong {typeof(arg_value)}}) must be the same {aname(x)} type as {aname(y)} ({typeof(y)})\")\n\n#' Assert input is less than a specified maximum value\n#'\n#' Assert all elements in a numeric vector/matrix are below some maximum value.\n#'\n#' @include assert_create.R\n#' @include assert_type.R\n#' @include is_functions.R\n#' @include is_comparisons.R\n#' @param x An object to check\n#' @param maximum The maximum value to compare against (number)\n#' @param msg A character string containing the error message to display if `x` is not less than the specified maximum value (string)\n#' @inheritParams common_roxygen_params\n#'\n#' @return invisible(TRUE) if `x` is less than the specified maximum value, otherwise aborts with the error message specified by `msg`\n#'\n#' @examples\n#' try({\n#' assert_all_less_than(1, 2) # Passes\n#' assert_all_less_than(c(1,2,3), 4) # Passes\n#' assert_all_less_than(c(1,2,3), 2) # Throws default error\n#' assert_all_less_than(c(1,2,3), 2, msg = \"custom error message\") # Throws custom error\n#' })\n#'\n#' @concept assert_comparison\n#' @export\nassert_all_less_than <- assert_create_chain(\n  assert_numeric,\n  assert_create(\n    is_less_than,\n    default_error_msg = \"{.strong {arg_name}} must {ifelse(length(arg_value) > 1, 'all ', '')}be {.strong less than} `{.strong {maximum}}`.\"\n  )\n)\n\n#' Assert input is less than some maximum value\n#'\n#' Assert a number is less than a specified maximum value.\n#' To check all numbers in a vector / matrix are below a maximum value, see [assert_all_less_than()]\n#'\n#' @include assert_create.R\n#' @include assert_type.R\n#' @include is_functions.R\n#' @include is_comparisons.R\n#' @param x An object to check\n#' @param maximum The maximum value to compare against (number)\n#' @param msg A character string containing the error message to display if `x` is not less than the specified maximum value (string)\n#' @inheritParams common_roxygen_params\n#'\n#' @return invisible(TRUE) if `x` is less than the specified maximum value, otherwise aborts with the error message specified by `msg`\n#'\n#' @examples\n#' try({\n#' assert_less_than(1, 2) # Passes\n#' assert_less_than(1, 2) # Passes\n#' assert_less_than(c(1,2,3), 4) # Throws error (Must be a number)\n#' assert_less_than('A', 1) # Throws error (Must be a number)\n#' assert_less_than(3, 2, msg = \"custom error message\") # Throws custom error\n#' })\n#'\n#' @concept assert_comparison\n#' @export\nassert_less_than <- assert_create_chain(\n  assert_number,\n  assert_all_less_than\n)\n\n#' Assert input is less than or equal to a specified maximum value\n#'\n#' Assert all elements in a numeric vector/matrix are below or equal to some maximum value.\n#'\n#' @param x An object to check\n#' @param maximum The maximum value to compare against\n#' @param msg A character string containing the error message to display if `x` is not less than or equal to the specified maximum value (string)\n#' @inheritParams common_roxygen_params\n#'\n#' @return invisible(TRUE) if `x` is less than or equal to the specified maximum value, otherwise aborts with the error message specified by `msg`\n#'\n#' @examples\n#' try({\n#' assert_less_than_or_equal_to(1, 2) # Passes\n#' assert_less_than_or_equal_to(c(1, 2, 3), 3) # Passes\n#' assert_less_than_or_equal_to(3, 2) # Throws error\n#' })\n#' @export\nassert_all_less_than_or_equal_to <- assert_create_chain(\n  assert_numeric,\n  assert_create(\n    is_less_than_or_equal_to,\n    default_error_msg = \"{.strong {arg_name}} must {ifelse(length(arg_value) > 1, 'all ', '')}be {.strong less than or equal to} `{.strong {maximum}}`.\"\n  )\n)\n\n#' Assert input is less than or equal to a specified maximum value\n#'\n#' Assert a number is less than or equal to a specified maximum value.\n#' For vectorized version see [assert_all_less_than_or_equal_to()]\n#'\n#' @param x An object to check\n#' @param maximum The maximum value to compare against\n#' @param msg A character string containing the error message to display if `x` is not less than or equal to the specified maximum value (string)\n#' @inheritParams common_roxygen_params\n#'\n#' @return invisible(TRUE) if `x` is less than or equal to the specified maximum value, otherwise aborts with the error message specified by `msg`\n#'\n#' @examples\n#' try({\n#' assert_less_than_or_equal_to(1, 2) # Passes\n#' assert_less_than_or_equal_to(c(1, 2, 3), 3) # Throws error\n#' assert_less_than_or_equal_to(3, 2) # Throws error\n#' })\n#' @export\nassert_less_than_or_equal_to <- assert_create_chain(\n  assert_number,\n  assert_all_less_than_or_equal_to\n)\n","type":"text"},{"name":"assertions/assert_create.R","content":"#' Create an assertion function\n#'\n#' This function creates an assertion function that can be used to check the\n#' validity of an input.\n#' All assertions provided with this package are created using either [assert_create()] or [assert_create_chain()]\n#'\n#' @param func A function defining the assertion criteria. This function should\n#'   return a logical value (`TRUE` when assertion is passed or `FALSE` when it fails).\n#'   Alternatively, instead of returning FALSE, you can return a string which will act as the error message.\n#'   In this latter case, you don't need to supply a `default_error_msg`\n#' @param default_error_msg A character string providing an error message in case\n#' the assertion fails. Must be supplied if function `func` returns `FALSE` when assertion fails (as opposed to a string)\n#' Can include the following special terms\n#`\n#' 1. `{arg_name}` to refer to the name of the variable supplied to the assertion.\n#'\n#' 2. `{arg_value}` to refer to the value of the variable supplied to the assertion\n#'\n#' 3. `{code_to_evaluate}` to evaluate the code within the error message.\n#' Replace `code_to_evaluate` with your code\n#'\n#' 4. `{.strong bold_text}` to perform inline formatting. Replace `bold_text` with your text.\n#' See [cli documentation](https://cli.r-lib.org/reference/inline-markup.html) for details\n#'\n#'\n#' @return An assertion function.\n#'\n#' @examples\n#' #' # Create an assertion function that checks that a character string is all\n#' # lower case\n#' assert_character <- assert_create(\n#'   is.character,\n#'   \"{arg_name} must be a character vector, not a {class(arg_value)}\"\n#' )\n#'\n#' # Use the assertion function\n#' try({\n#' is_lower(\"hello\") # Returns invisible TRUE\n#' is_lower(\"Hello\") # Aborts the function with the error message\n#'})\n#' @include utils.R\n#' @concept assert_create\n#' @export\nassert_create <- function(func, default_error_msg = NULL){\n\n  # Check arguments\n  function_name <- paste0(deparse(substitute(func)), collapse = \"\")\n\n\n  # Ensure func is a valid function\n  if(!is.function(func)){\n    cli::cli_abort(\"`{function_name}` must be a function, not a {class(func)}\")\n  }\n\n  # Ensure func has at least 1 argument\n  if(func_arg_count(func, dots = \"count_as_0\") == 0){\n    if (func_supports_variable_arguments(func))\n      additional_note = \" (Note '...' does NOT count as an argument)\"\n    else additional_note = \"\"\n\n    cli::cli_abort(\"`{function_name}` must have at least 1 paramater to be used in `assert_create`{additional_note}\")\n  }\n\n  # Ensure default_error_msg is a string\n  if(!is.null(default_error_msg) & !is_string(default_error_msg)){\n    default_error_msg_deparsed <- deparse(substitute(default_error_msg))\n    cli::cli_abort(\"{default_error_msg_deparsed} must be a string (length 1 character vector). Class: {class(default_error_msg)}; Length: {length(default_error_msg)}\")\n  }\n\n  # Get arguments of user supplied function\n  args <- func_args_as_pairlist(func)\n\n  # Assert that function has no arguments named 'msg' or 'call', 'arg_name', since we need to add our own\n  if(any(c('msg', 'call', 'arg_name') %in% names(args))){\n    cli::cli_abort(\"Function supplied to `func` argument of `assert_create` cannot include paramaters named 'msg', 'call', or 'arg_name', since assert_create adds these arguments to every assertion\")\n  }\n\n  # Change add 'msg', 'call' and 'arg_name' arguments at the end\n  #args <- append(args, as.pairlist(alist(x = )), after = 0)\n  args <- append(args, as.pairlist(alist(msg = NULL, call = rlang::caller_env(), arg_name = NULL)),after = Inf)\n\n\n  # Create body of assertion function\n  body = quote({\n\n    # Check mandatory arguments are all supplied\n    if(required_args_are_missing())\n      cli::cli_abort('mandatory argument/s were not supplied')\n\n    # Setup some variables ( these will be useful later)\n    if(is.null(arg_name))\n      arg_name <- deparse(match.call()[[2]])\n    else if(!is_string(arg_name))\n     cli::cli_abort(\"{.strong arg_name} must be a string, not a {class(arg_name)}\")\n\n    # Create arg_value val\n    arg_value <- eval(match.call()[[2]], envir = call)\n\n    # Create useful functions\n    #.name <- function(obj) { browser(); deparse(substitute(obj, env)) }\n\n\n    # Get the list of arguments with values explicitly supplied in function call\n    explicit_args <- as.list(match.call())[-1]\n\n    # Assert all arguments without defaults are explicitly supplied in the function call\n    arg_has_default <- !unlist(as.list(formals()) == substitute())\n    args_without_defaults <- names(arg_has_default)[arg_has_default == FALSE]\n    args_missing <- args_without_defaults[!args_without_defaults %in% names(explicit_args)]\n    if(length(args_missing) > 0){\n      cli::cli_abort(\"{args_missing} are required, with no default\")\n    }\n\n    # Create list of arguments - value pairs to be called with func (using do.call)\n    # Lets just supply x in position 1 (unnamed), then pass whatevers supplied by arg_has_default with its original names\n    names(explicit_args)[1] <- \"\" # unname first argument\n\n    # Also filter out msg & call arguments the user supplied func won't understand these\n    explicit_args_for_func <- explicit_args[!names(explicit_args) %in% c(\"msg\", \"call\", \"arg_name\")]\n\n\n    # Info\n    #cli::cli_alert_info(\"Calling `func` using the argument values: {paste0(names(explicit_args_for_func), ' = ', explicit_args_for_func)}\")\n\n    # Call supplied function\n    condition <- do.call(func, args = explicit_args_for_func, envir = parent.frame())\n\n    if(!(is.logical(condition) || is.character(condition)) || length(condition) != 1) # Change to is.flag once this method is created\n      cli::cli_abort(\"Assertion Function `{.strong {function_name}}` must return TRUE if assertion passes and FALSE or a String if assertion should fail. Instead returned: `{condition}`\")\n\n    if(isFALSE(condition) & is.null(default_error_msg))\n      cli::cli_abort(\"Assertion Function `{.strong {function_name}}` returned FALSE, indicating assertion should fail, however no {.arg default_error_msg} was supplied! Please add a {.arg default_error_msg} to your assert_create call, or change function to return a string describing the error instead of `FALSE`\")\n\n    # If user doesn't supply an error message, set msg to the default\n    if(is.null(msg)){\n      msg_evaluation_environment <- rlang::current_env() # Evaluate error message in current envrionment\n     if(isFALSE(condition))\n      msg <- default_error_msg\n\n     else if(is.character(condition))\n      msg <- condition\n    }\n    else { # If user does supply a default error message\n      msg_evaluation_environment <- rlang::caller_env(n = 1) # Evaluate it in caller environment\n      # Add special keywords to environment:\n      # arg_name, arv_value\n      assign(\"arg_name\", value = arg_name, envir = msg_evaluation_environment)\n      assign(\"arg_value\", value = arg_value, envir = msg_evaluation_environment)\n    }\n\n    # If assertion fails, abort with error statement\n    if(is.character(condition) || !condition )\n      cli::cli_abort(msg, call = call, .envir = msg_evaluation_environment)\n    else\n      return(invisible(TRUE))\n  })\n\n  # Create assertion_function\n  assertion_function <- rlang::new_function(args, body, env = rlang::env(func = func))\n\n  return(assertion_function)\n}\n\n\n\n#' @title Create Chains of Assertions\n#'\n#' @description\n#' Combine multiple assertion functions created by `assert_create()` into a single assertion function with diverse failure modes and error messages.\n#'\n#' @param ... assertion functions created by `assert_create()`.\n#'\n#' @return A single assertion function that calls each of the input functions in the order they are supplied.\n#'\n#'\n#' @examples\n#' # Create an assertion function that checks for both positive integers and even values\n#' assert_string <- assert_create_chain(\n#'   assert_create(is.character, '{{arg_name}} must be a character'),\n#'   assert_create(function(x){{ length(x)==1 }}, '{{arg_name}} must be length 1')\n#'   )\n#'\n#' # Use the assertion function to check a valid value\n#' assert_string(\"String\")\n#'\n#' # Use the assertion function to check an invalid value\n#' try({\n#' assert_string(3)\n#' # Output: Error: '3' must be a character\n#' })\n#' @export\nassert_create_chain <- function(...){\n\n  # Get list of arguments\n  dot_args <- list(...)\n\n  # Check dot_args are all functions\n  lgl_is_function <- vapply(dot_args, is.function, FUN.VALUE = logical(1))\n  if(!all(lgl_is_function)){\n    cli::cli_abort(\n      c(\"Input to {.strong assert_create_chain} must must be {.strong functions} created by {.strong `assert_create()`}\",\n        \"\",\n        assert_create_chain_example()\n      ))\n  }\n\n  # Check functions all have the required arguments (msg, call and arg_name)\n  if(!all(vapply(dot_args, function(f){ all(c('msg', 'call', 'arg_name') %in% func_arg_names(f)) }, FUN.VALUE = logical(1)))){\n    cli::cli_abort(\n      c(\"Input to {.strong assert_create_chain} must must be {.strong functions} created by {.strong `assert_create()`}\",\n        \"\",\n        assert_create_chain_example()\n      ))\n  }\n\n  # Check functions have at least 4 args (some_obj_to_test and officially required functions: msg, call, arg_name)\n  if(!all(vapply(dot_args, function(f){ func_arg_count(f) >= 4 }, FUN.VALUE = logical(1)))){\n    cli::cli_abort(\n      c(\"Input to {.strong assert_create_chain} must must be {.strong functions} created by {.strong `assert_create()`}\",\n        \"\",\n        assert_create_chain_example()\n      ))\n  }\n\n  # Save assertion functons in a list\n  assertion_functions <- dot_args\n\n  # Get arguments of each assertion function\n  param_pairlist_nested <- lapply(assertion_functions, func_args_as_pairlist)\n  param_pairlist_flat <- unlist(param_pairlist_nested, recursive = FALSE)\n  param_pairlist <- param_pairlist_flat[!duplicated(names(param_pairlist_flat))]\n\n  # reorder arguments so that arguments to functions take precedence\n  args_to_put_at_end <- c(\"msg\", \"call\", \"arg_name\")\n  param_pairlist <- c(param_pairlist[!(names(param_pairlist) %in% args_to_put_at_end)], param_pairlist[names(param_pairlist) %in% args_to_put_at_end])\n\n\n\n  #unique_params <- unlist(unique(arglist))\n\n  # Return a wrapper function that calls each of the functions\n  chained_assertion_function <- rlang::new_function(\n    args = param_pairlist,\n    body = quote({\n\n\n      arg_name_upperlevel <- deparse(substitute(x))\n\n      explicit_args <- as.list(match.call())[-1]\n      explicit_args <- lapply(explicit_args, function(a) {\n        if(is.symbol(a))\n          eval.parent(a, n = 3)\n        else return(a)\n      })\n\n      # Assert all arguments without defaults are explicitly supplied in the function call\n      arg_has_default <- !unlist(as.list(formals()) == substitute())\n      args_without_defaults <- names(arg_has_default)[arg_has_default == FALSE]\n      args_missing <- args_without_defaults[!args_without_defaults %in% names(explicit_args)]\n      if(length(args_missing) > 0){\n        cli::cli_abort(\"{args_missing} are required, with no default\")\n      }\n\n\n      # If user doesn't override `explicit_args`, set to variable name\n      # This lets downstream functions use the correct variable name as {arg_name}\n      if(!\"arg_name\" %in% names(explicit_args)){\n        explicit_args <- append(explicit_args, list(arg_name = arg_name_upperlevel), after = Inf)\n      }\n\n      # Do a simliar thing with call, since if you just let the assertions use the default call, it will be the assertion functions parent env, not the caller\n      if(! \"call\" %in% names(explicit_args)){\n        explicit_args <- append(explicit_args, list(call = call), after = Inf)\n      }\n\n      for (f in assertion_functions) {\n        # filter explicit_args for only the functions args that 'f' understands.\n        args_relevant_to_function_f <- explicit_args[names(explicit_args) %in% func_arg_names(f)]\n        do.call(what = f, args = args_relevant_to_function_f, envir = rlang::caller_env())\n      }\n      return(invisible(TRUE))\n      }),\n    env = rlang::env(assertion_functions = assertion_functions)\n  )\n  return(chained_assertion_function)\n}\n\n\nassert_create_chain_example <- function(){\n  c(\n  \"{.strong For example:}\",\n  \"assert_string <- assert_create_chain(\",\n  ' ' = \"assert_create(is.character, '{{arg_name}} must be a character'),\",\n  ' ' = \"assert_create(function(s){{ length(s)==1 }}, '{{arg_name}} must be length 1')\",\n  \")\"\n)\n}\n","type":"text"},{"name":"assertions/assert_dataframe.R","content":[],"type":"text"},{"name":"assertions/assert_files.R","content":"# Functions ---------------------------------------------------------------\n\nall_files_exist <- function(x){\n  all(file.exists(x))\n}\n\n\nis_dir <- function(x){\n  all(dir.exists(x))\n}\n\nis_file <- function(x){\n  all(file.exists(x) & !dir.exists(x))\n}\n\nfile_or_dir <- function(x){\n  if(is_file(x)) return ('File')\n  else if(is_dir(x)) return('Directory')\n  else return('Unknown filetype')\n}\n\nget_file_extensions <- function(filenames) {\n  filenames <- basename(filenames)\n\n  vapply(filenames, function(x) {\n    extension <- sub(\"^.*\\\\.\", \"\", x)\n    if (extension == x) extension <- \"\"\n    extension\n  }, character(1))\n}\n\n#' Has Extension\n#'\n#' @param x object to test\n#' @param extensions valid extensions (character vector). Do not include the '.', e.g. supply `extensions = 'txt'` not `extensions = '.txt'`\n#' @param compression should compression extension ‘.gz’, ‘.bz2’ or ‘.xz’ be removed first?\n#'\n#' @return TRUE if all x have valid extensions as supplied by `extensions` (flag)\n#'\nhas_extension <- function(x, extensions, compression = FALSE){\n  if(compression){\n    x = sub(x = x,\"\\\\.(gz|bz2|xz)$\",\"\")\n  }\n\n  observed_ext <- get_file_extensions(x)\n  all(observed_ext %in% extensions)\n}\n\n# Which of the filenames are missing the required extension?\nfiles_missing_extension <- function(x, extensions, compression = FALSE){\n  original = x\n  if(compression){\n  x = sub(x = x,\"\\\\.(gz|bz2|xz)$\",\"\")\n  }\n\n  observed_ext <- get_file_extensions(x)\n  original[!observed_ext %in% extensions]\n}\n\n# File Assertions ---------------------------------------------------------------\n\n#' Assert that all files exist\n#'\n#' Assert all files in vector exist. To assert a single file exists, see [assert_file_exists()]\n#'\n#' @include assert_create.R\n#' @include is_functions.R\n#' @param x Paths to files (character)\n#' @param msg A character string containing the error message if any files in `x` is does not exist\n#' @inheritParams common_roxygen_params\n#' @inheritParams assert_character_vector\n#' @return invisible(TRUE) if all files in `x` exist, otherwise aborts with the error message specified by `msg`\n#'\n#' @examples\n#' real_file <- system.file(\"DESCRIPTION\", package = \"assertions\")\n#'\n#' try({\n#' assert_all_files_exist(c(real_file, real_file))\n#' assert_all_files_exist(c(\"foo\", \"bar\")) # Throws Error\n#' })\n#'\n#' @concept assert_file\n#' @export\nassert_all_files_exist <- assert_create_chain(\n  assert_character_vector_or_glue,\n  assert_create(func = all_files_exist, default_error_msg = \"Failed to find file{?s}: {.file {arg_value[!file.exists(arg_value)]}}\"),\n  assert_create(func = is_file, default_error_msg = \"{x[dir.exists(x)]} {?is a/are} {.strong director{?y/ies}}, not {?a/} {.strong file{?s}}\")\n)\n\n\n#' Assert a file exists\n#'\n#' Assert that a file exists.\n#' To assert all files in a vector exist, see [assert_all_files_exist()]\n#'\n#' @include assert_create.R\n#' @include is_functions.R\n#' @param x Path to a file (string)\n#' @param msg A character string containing the error message if file `x` is does not exist\n#' @inheritParams common_roxygen_params\n#' @inheritParams assert_all_files_exist\n#' @return invisible(TRUE) if file `x` exists, otherwise aborts with the error message specified by `msg`\n#'\n#' @examples\n#' real_file <- system.file(\"DESCRIPTION\", package = \"assertions\")\n#'\n#' try({\n#' assert_file_exists(real_file) # PASSES\n#' assert_file_exists(\"foo\") # Throws Error\n#' assert_file_exists(c(real_file, real_file)) # Throws Error (should use assert_all_files_exist)\n#'\n#' })\n#'\n#' @concept assert_file\n#' @export\nassert_file_exists <- assert_create_chain(\n  assert_string,\n  assert_all_files_exist\n)\n\n\n#' Assert a file does not exist\n#'\n#' Assert that a file does not exist. Useful for avoiding overwriting.\n#'\n#' @param x Path to a file (string)\n#' @param msg A character string containing the error message if file `x` already exists\n#' @inheritParams common_roxygen_params\n#' @return invisible(TRUE) if file `x` does not exist, otherwise aborts with the error message specified by `msg`\n#'\n#' @examples\n#' real_file <- system.file(\"DESCRIPTION\", package = \"assertions\")\n#'\n#' try({\n#' assert_file_does_not_exist(\"foo\") # Passes\n#' assert_file_does_not_exist(real_file) # Throws error\n#' assert_file_does_not_exist(c(\"foo\", \"bar\")) # Throws Error (single file only)\n#' })\n#'\n#' @concept assert_file\n#' @export\nassert_file_does_not_exist <- assert_create_chain(\n  assert_string,\n  assert_create(\n    func = function(x){!file.exists(x)},\n    default_error_msg = \"{.strong {file_or_dir(arg_value)} ({.path {arg_value}})} already exists\"\n    )\n)\n\n#' Assert a directory does not exist\n#'\n#' Assert that a directory does not already exist. Useful for avoiding overwriting.\n#' This function is an exact copy of [assert_file_does_not_exist()] and included to make assertion code more readable.\n#'\n#' @param x Path to a file (string)\n#' @param msg A character string containing the error message if file `x` already exists\n#' @inheritParams common_roxygen_params\n#' @return invisible(TRUE) if directory `x` does not already exist, otherwise aborts with the error message specified by `msg`\n#'\n#' @examples\n#' real_dir <- system.file(\"tests\", package = \"assertions\")\n#'\n#' try({\n#' assert_directory_does_not_exist(\"foo\") # Passes\n#' assert_directory_does_not_exist(real_dir) # Throws error\n#' assert_directory_does_not_exist(c(\"foo\", \"bar\")) # Throws Error (single file only)\n#' })\n#'\n#' @concept assert_file\n#' @export\nassert_directory_does_not_exist <- assert_file_does_not_exist\n\n#' Assert all files are directories\n#'\n#' Assert that all paths supplied exist and are directories.\n#' To assert a single directory exists, see [assert_directory_exists()]\n#'\n#'\n#' @include assert_create.R\n#' @include is_functions.R\n#' @param x Paths to directories (character)\n#' @param msg A character string containing the error message if file `x` is does not exist\n#' @inheritParams common_roxygen_params\n#' @inheritParams assert_character\n#'\n#' @return invisible(TRUE) if `x` is exists and is a directory, otherwise aborts with the error message specified by `msg`\n#'\n#' @examples\n#' try({\n#' assert_directory(system.file(\"package = assertions\")) # PASSES\n#' assert_directory(\"foo\") # Throws Error\n#' })\n#'\n#' @concept assert_file\n#' @export\nassert_all_directories_exist <- assert_create_chain(\n  assert_character_vector_or_glue,\n  assert_create(func = all_files_exist, default_error_msg = \"Failed to find director{?y/ies}: {.file {arg_value[!file.exists(arg_value)]}}\"),\n  assert_create(is_dir, default_error_msg = \"{.strong {arg_value[!dir.exists(arg_value)]}} {?is a/are} {.strong file{?s}}, not{? a/} {.strong director{?y/ies}}\")\n)\n\n#' Assert are directory exists\n#'\n#' Assert a directory exists.\n#' To assert all directories in a vector exist, see [assert_all_directories_exist()]\n#'\n#' @include assert_create.R\n#' @include is_functions.R\n#' @param x Path to a directory (string)\n#' @param msg A character string containing the error message if file `x` is does not exist\n#' @inheritParams common_roxygen_params\n#' @inheritParams assert_all_directories_exist\n#' @return invisible(TRUE) if `x` is exists and is a directory, otherwise aborts with the error message specified by `msg`\n#'\n#' @examples\n#' try({\n#' assert_directory_exists(system.file(\"package = assertions\")) # PASS\n#' assert_all_directories_exist(\"foo\") # Throws Error\n#' })\n#'\n#' @concept assert_file\n#' @export\nassert_directory_exists <- assert_create_chain(\n  assert_string,\n  assert_all_directories_exist\n)\n\n#' Assert file extensions\n#'\n#' Assert that all filepaths supplied have one of the selected extensions. Does not require file to actually exist.\n#'\n#'\n#' @include assert_create.R\n#' @include is_functions.R\n#'\n#' @param x An object\n#' @param msg A character string containing the error message if file `x` does not have the specified extensions\n#' @inheritParams common_roxygen_params\n#' @inheritParams has_extension\n#' @inheritParams assert_character\n#' @return invisible(TRUE) if `x` has any of the specified extensions, otherwise aborts with the error message specified by `msg`\n#'\n#' @examples\n#' try({\n#' assert_all_files_have_extension(c(\"foo.txt\", \"bar.txt\"), extensions = \"txt\") # Passes\n#' assert_all_files_have_extension(c(\"foo.txt\", \"bar.csv\"), extensions = \"csv\") # Throws Error\n#' })\n#'\n#' @concept assert_file\n#'\n#' @export\nassert_all_files_have_extension <- assert_create_chain(\n  assert_character_vector_or_glue,\n  assert_create(has_extension, \"'{.strong {arg_name}}' {cli::qty(files_missing_extension(arg_value, extensions, compression))}{?has/have} an invalid extension (required extension/s: {.strong {extensions}}).\n  The following {cli::qty(files_missing_extension(arg_value, extensions, compression))} file{?s} ha{?s an/ve} unexpected extension{?s}:\n  [{files_missing_extension(arg_value, extensions, compression)}]\"\n  )\n)\n\n#' Assert file extensions\n#'\n#' Assert that a filepath includes one of the selected extensions. Does not require file to actually exist.\n#'\n#'\n#' @include assert_create.R\n#' @include is_functions.R\n#'\n#' @param x An object\n#' @param msg A character string containing the error message if file `x` does not have the specified extensions\n#' @inheritParams common_roxygen_params\n#' @inheritParams has_extension\n#' @inheritParams assert_all_files_have_extension\n#' @return invisible(TRUE) if `x` has any of the specified extensions, otherwise aborts with the error message specified by `msg`\n#'\n#' @examples\n#' try({\n#' assert_file_has_extension(\"foo.txt\", extensions = \"txt\") # Passes\n#' assert_file_has_extension(\"file.txt\", extensions = \"csv\") # Throws Error\n#' })\n#'\n#' @concept assert_file\n#'\n#' @export\nassert_file_has_extension <- assert_create_chain(\n  assert_string,\n  assert_all_files_have_extension\n)\n","type":"text"},{"name":"assertions/assert_functions.R","content":"# Notes -------------------------------------------------------------------\n\n# assert_function is in assert_type.\n# All other assertions that run on func are here\n# utilities for probing functions are in utils.R\n\n\n# Advanced Functions ------------------------------------------------------\nfunction_expects_n_arguments_advanced <- function(x, n, dots = c(\"throw_error\",\"count_as_0\", \"count_as_1\", \"count_as_inf\")){\n  dots <- rlang::arg_match(dots)\n\n  if(!is.function(x))\n    return(\"{.strong '{arg_name}'} must be a function, not a {class(arg_value)}\")\n\n  if(func_supports_variable_arguments(x) && dots == \"throw_error\")\n    return(\"{.strong '{arg_name}'} must not contain ... arguments\")\n\n\n  number_of_parameters <- func_arg_count(x, dots = dots)\n\n  if(number_of_parameters != n)\n    return(paste0(\"{.strong '{arg_name}'} must expect exactly {.strong {n}} argument{?s}, not {.strong \", number_of_parameters, \"}\"))\n\n  return(TRUE)\n}\n\n\n# Assertions --------------------------------------------------------------\n\n#' Assert function expects n arguments\n#'\n#' Assert a function expects n arguments, with user control over how variable arguments (...) are counted (default throws error)\n#'\n#' @include assert_create.R\n#' @include utils.R\n#' @param x a function to check has exactly N arguments\n#' @param n number of arguments that must be expected by function to pass assertion (integer)\n#' @param dots how to deal with '...' dots (a.k.a variable arguments). Should we count as 0, 1 or infinite arguments. Or, do we just throw an error when we see '...' (default)\n#' @inheritParams common_roxygen_params\n#'\n#' @return invisible(TRUE) if function `x` expects exactly n arguments, otherwise aborts with the error message specified by `msg`\n#'\n#' @export\nassert_function_expects_n_arguments <- assert_create(func = function_expects_n_arguments_advanced)\n","type":"text"},{"name":"assertions/assert_includes.R","content":"#' Assert object includes required\n#'\n#' Assert x includes required elements\n#'\n#' @include assert_create.R\n#' @include set_operations.R\n#' @param x An object\n#' @param msg A character string describing the error message if `x` does not include `required` elements\n#' @inheritParams common_roxygen_params\n#' @inheritParams includes_advanced\n#'\n#' @return invisible(TRUE) if `x` includes all `required` elements, otherwise aborts with the error message specified by `msg`\n#'\n#' @examples\n#' try({\n#' assert_directory(system.file(\"package = assertions\"))\n#' assert_directory(\"foo\") # Throws Error\n#' })\n#'\n#' @concept assert_includes\n#' @export\nassert_includes <- assert_create(\n  includes_advanced\n)\n\n#' Assert object does not include any illegal values\n#'\n#' Assert x does not include illegal elements\n#'\n#' @include assert_create.R\n#' @include set_operations.R\n#' @param x An object\n#' @param msg A character string describing the error message if `x` includes any `illegal` elements\n#' @inheritParams common_roxygen_params\n#' @inheritParams excludes_advanced\n#'\n#' @return invisible(TRUE) if `x` includes any `illegal` elements, otherwise aborts with the error message specified by `msg`\n#'\n#' @examples\n#' try({\n#' assert_directory(system.file(\"package = assertions\"))\n#' assert_directory(\"foo\") # Throws Error\n#' })\n#'\n#' @concept assert_includes\n#' @export\nassert_excludes <- assert_create(\n  excludes_advanced\n)\n","type":"text"},{"name":"assertions/assert_length.R","content":"# Assert Length -----------------------------------------------------------\n\n#' Assert Length\n#'\n#' Assert object has a specific length\n#'\n#' @param x object to check length of\n#' @param length expected length (number)\n#' @param msg custom error message\n#' @param call (logical) whether to preserve call in error message\n#' @param arg_name (character) name of argument being tested\n#'\n#' @return invisible(TRUE)\n#' @export\nassert_length <- assert_create(\n  func = function(x, length) {\n    if(!is.numeric(length)) return(\"'length' must be numeric\")\n    if(length(length) != 1) return(\"'length' must be a single number\")\n    if(!is_whole_number(length)) return(\"'length' must be a whole number\")\n    if(length < 0) return(\"'length' must be non-negative\")\n    \n    length(x) == length\n  },\n  default_error_msg = \"'{arg_name}' must have length {length}, not {length(arg_value)}\"\n)\n\n#' Assert Length Greater Than\n#'\n#' Assert object length is greater than a threshold\n#'\n#' @inheritParams assert_length\n#' @return invisible(TRUE)\n#' @export\nassert_length_greater_than <- assert_create(\n  func = function(x, length) {\n    if(!is.numeric(length)) return(\"'length' must be numeric\")\n    if(length(length) != 1) return(\"'length' must be a single number\")\n    if(!is_whole_number(length)) return(\"'length' must be a whole number\")\n    if(length < 0) return(\"'length' must be non-negative\")\n    \n    length(x) > length\n  },\n  default_error_msg = \"'{arg_name}' must have length greater than {length}, not {length(arg_value)}\"\n)\n\n#' Assert Length Greater Than or Equal To\n#'\n#' Assert object length is greater than or equal to a threshold\n#'\n#' @inheritParams assert_length\n#' @return invisible(TRUE)\n#' @export\nassert_length_greater_than_or_equal_to <- assert_create(\n  func = function(x, length) {\n    if(!is.numeric(length)) return(\"'length' must be numeric\")\n    if(length(length) != 1) return(\"'length' must be a single number\")\n    if(!is_whole_number(length)) return(\"'length' must be a whole number\")\n    if(length < 0) return(\"'length' must be non-negative\")\n    \n    length(x) >= length\n  },\n  default_error_msg = \"'{arg_name}' must have length greater than or equal to {length}, not {length(arg_value)}\"\n)\n\n#' Assert Length Less Than\n#'\n#' Assert object length is less than a threshold\n#'\n#' @inheritParams assert_length\n#' @return invisible(TRUE)\n#' @export\nassert_length_less_than <- assert_create(\n  func = function(x, length) {\n    if(!is.numeric(length)) return(\"'length' must be numeric\")\n    if(length(length) != 1) return(\"'length' must be a single number\")\n    if(!is_whole_number(length)) return(\"'length' must be a whole number\")\n    if(length < 0) return(\"'length' must be non-negative\")\n    \n    length(x) < length\n  },\n  default_error_msg = \"'{arg_name}' must have length less than {length}, not {length(arg_value)}\"\n)\n\n#' Assert Length Less Than or Equal To\n#'\n#' Assert object length is less than or equal to a threshold\n#'\n#' @inheritParams assert_length\n#' @return invisible(TRUE)\n#' @export\nassert_length_less_than_or_equal_to <- assert_create(\n  func = function(x, length) {\n    if(!is.numeric(length)) return(\"'length' must be numeric\")\n    if(length(length) != 1) return(\"'length' must be a single number\")\n    if(!is_whole_number(length)) return(\"'length' must be a whole number\")\n    if(length < 0) return(\"'length' must be non-negative\")\n    \n    length(x) <= length\n  },\n  default_error_msg = \"'{arg_name}' must have length less than or equal to {length}, not {length(arg_value)}\"\n)\n","type":"text"},{"name":"assertions/assert_names.R","content":"#' Check if a named object has all specified names\n#'\n#' This function returns a logical value indicating whether the object `x` has all the names specified in `names`.\n#'\n#' @param x a named object\n#' @param names A character vector of names to check for in `x`.\n#' @return A logical value indicating whether `x` has all the names specified in `names`\nhas_all_names <- function(x, names){\n  is_subset(names, names(x))\n}\n\n\n\n#' Assert that the input object includes a specified name\n#'\n#' @param x An object to check for the presence of specific names\n#' @param names A character vector of names to check for in `x`\n#' @param msg A character string containing the error message to display if any of the `names` are not present in `x`\n#' @inheritParams common_roxygen_params\n#' @inheritParams has_all_names\n#' @return invisible(TRUE) if all `names` are present in `x`, otherwise aborts with the error message specified by `msg`\n#' @include is_functions.R\n#' @examples\n#' try({\n#' x <- list(a = 1, b = 2, c = 3)\n#'\n#' assert_includes_name(x, \"a\") # Passes\n#' assert_includes_name(x, c(\"a\", \"b\")) # Passes\n#' assert_includes_name(x, c(\"a\", \"b\", \"d\")) # Throws default error message\n#'\n#' assert_includes_name(x, c(\"a\", \"b\", \"d\"), \"Custom error message\") # Throws custom error message\n#' })\n#'\n#' @export\nassert_names_include <- assert_create(\n  has_all_names,\n  \"'{.strong {arg_name}}' is missing {.strong {setopts_count_exlusive_to_first(names, names(arg_value))}} required name{?s}:\n  {.strong `{setopts_exlusive_to_first(names, names(arg_value))}`}\"\n)\n","type":"text"},{"name":"assertions/assert_null.R","content":"#' Assert that the input is NULL\n#'\n#' This function asserts that the input is NULL and aborts with an error message if it is not.\n#'\n#' @param x A value to check.\n#' @param msg A character string containing the error message to display if `x` is not NULL.\n#' @inheritParams common_roxygen_params\n#'\n#' @return invisible(TRUE) if `x` is NULL, otherwise aborts with the error message specified by `msg`.\n#'\n#' @examples\n#' assert_null(NULL)  # Passes\n#' \n#' try({\n#'  assert_null(1)  # Throws default error\n#'  assert_null(1, msg = \"Custom error message\")  # Throws custom error\n#' })\n#' \n#' @export\nassert_null <- assert_create(\n  is.null,\n  \"'{.strong {arg_name}}' must be NULL!\"\n)\n\n#' Assert that the input is not NULL\n#'\n#' This function asserts that the input is not NULL and aborts with an error message if it is.\n#'\n#' @param x A value to check.\n#' @param msg A character string containing the error message to display if `x` is NULL.\n#' @inheritParams common_roxygen_params\n#'\n#' @return invisible(TRUE) if `x` is not NULL, otherwise aborts with the error message specified by `msg`.\n#'\n#' @examples\n#' \n#' # Passes for non-NULL\n#' assert_non_null(1)\n#' \n#' try({\n#'  # Throws default error for NULL\n#'  assert_non_null(NULL)\n#' \n#'  # Throws custom error message\n#'  assert_non_null(NULL, msg = \"Custom error message\")\n#' })\n#' @export\nassert_non_null <- assert_create(\n  function(x) !is.null(x),\n  \"'{.strong {arg_name}}' must not be NULL!\"\n)\n","type":"text"},{"name":"assertions/assert_numerical.R","content":"# For assert_number see assert_type. All other numerical assertions are here\n\n#' Assert that the input object is a whole number\n#'\n#' Check if `x` is a whole number (no decimal)\n#'\n#' @param x An object\n#' @inheritParams common_roxygen_params\n#'\n#' @return invisible(TRUE) if `x` is a whole number, otherwise aborts with the error message specified by `msg`\n#'\n#' @examples\n#' try({\n#' assert_whole_number(24) # Passes\n#' assert_whole_number(2.5) # Throws error\n#' })\n#'\n#' @concept assert_numerical\n#' @export\nassert_whole_number <- assert_create_chain(\n  assert_number,\n  assert_create(\n    func = is_whole_number,\n    default_error_msg = \"'{.strong {arg_name}}' is not a {.strong whole} number\")\n)\n","type":"text"},{"name":"assertions/assert_set.R","content":"#' Check if a vector is a subset of another\n#'\n#' This function checks that `x` is a subset of `y`\n#'\n#' @param x A vector to check\n#' @param y the acceptable values that x can take\n#' @inheritParams common_roxygen_params\n#'\n#' @return Returns invisible(TRUE) if `x` is a subset of `y`, otherwise throws an error\n#' @examples\n#' try({\n#' assert_subset(1:3, 1:5) # Passes\n#' assert_subset(c(\"A\", \"B\", \"C\"), c(\"A\", \"B\")) # Throws error since \"C\" is not present in first vector\n#' })\n#' @export\nassert_subset <- assert_create(\n  func = is_subset,\n  default_error_msg = c(\n    x = \"'{.strong {arg_name}}' {cli::qty(length(setopts_exlusive_to_first(arg_value, y)))} contain{?s} {?an/} invalid value{?s}: {.strong {setopts_exlusive_to_first(arg_value, y)}}. Valid values include: {unique(y)}\"\n  )\n)\n\n\n#' Check if a scalar value is one of the acceptable values\n#'\n#' Assert `x` is one of the values of `y`.\n#'\n#' @param x A scalar value to check\n#' @param y A vector of acceptable values that `x` can take\n#' @inheritParams common_roxygen_params\n#'\n#' @return Returns invisible(TRUE) if `x` is a scalar and is one of the values in `y`, otherwise throws an error\n#' @examples\n#' assert_one_of(3, 1:5) # Passes because 3 is in 1:5\n#' assert_one_of(\"A\", c(\"A\", \"B\", \"C\")) # Passes because \"A\" is in the vector\n#'\n#' try({\n#'   assert_one_of(\"D\", c(\"A\", \"B\", \"C\")) # Throws error because \"D\" is not in the vector\n#' })\n#' @export\nassert_one_of <- assert_create_chain(\n  assert_scalar,\n  assert_create(\n    func = is_subset,\n    default_error_msg = c(\n      x = \"'{.strong {arg_name}}' must be one of {.or {cli::cli_vec(y)}}, not {arg_value}.\"\n    )\n  )\n)\n\n\n#' Check if two sets are identical\n#'\n#' This function checks that `x` and `y` contain exactly the same elements, ignoring order and duplicates.\n#'\n#' @param x A vector to compare\n#' @param y Another vector to compare with `x`\n#' @inheritParams common_roxygen_params\n#'\n#' @return Returns `invisible(TRUE)` if `x` and `y` contain all the same elements (ignoring order and duplicates), otherwise throws an error.\n#' @examples\n#' # Passes because elements are the same, order doesn't matter\n#' assert_set_equal(c(1, 2, 3), c(3, 2, 1))\n#'\n#' # Passes because elements are identical\n#' assert_set_equal(c(\"A\", \"B\", \"C\"), c(\"C\", \"A\", \"B\"))\n#'\n#' try({\n#'   # Throws error because elements are not identical\n#'   assert_set_equal(c(1, 2, 3), c(1, 2))\n#'\n#'   # Throws error because elements differ\n#'   assert_set_equal(c(\"A\", \"B\"), c(\"A\", \"B\", \"C\"))\n#' })\n#' @export\nassert_set_equal <- assert_create(\n  func = sets_are_equivalent\n)\n","type":"text"},{"name":"assertions/assert_type.R","content":"\n# Utils -------------------------------------------------------------------\nmsg_helper_assert_type <- function(expected_type, a = TRUE, an =FALSE){\n  a <- ifelse(a, \"a \", \"\")\n  a <- ifelse(an, \"an \", a)\n\n  paste0(\"'{.strong {arg_name}}' must be \",a,\"{.strong \",expected_type,\"}, not a {.strong {class(arg_value)}}\")\n\n}\n\n# Dataframe ---------------------------------------------------------------\n#' Assert input is a data frame\n#'\n#' @include assert_create.R\n#' @include is_functions.R\n#' @param x An object\n#' @param msg A character string containing the error message to display if `x` is not a data frame\n#' @inheritParams common_roxygen_params\n#'\n#' @return invisible(TRUE) if `x` is a data frame, otherwise aborts with the error message specified by `msg`\n#'\n#' @examples\n#' try({\n#' assert_dataframe(mtcars) # Passes\n#' assert_dataframe(data.frame()) # Passes\n#'\n#' assert_dataframe(1:10) # Throws default error\n#' assert_dataframe(matrix(1:6, 2, 3)) # Throws default error\n#' assert_dataframe(c(1, 2, 3)) # Throws default error: \"Error\n#' assert_dataframe(list(a = 1, b = 2)) # Throws default error\n#' assert_dataframe(factor(c(1, 2, 3))) # Throws default error\n#'\n#' assert_dataframe(1:10, msg = \"Custom error message\") # Throws custom error\n#' })\n#'\n#'\n#' @concept assert_type\n#' @export\nassert_dataframe <- assert_create(\n  func = is.data.frame,\n  default_error_msg = msg_helper_assert_type(\"data.frame\")\n)\n\n\n# Matrix ------------------------------------------------------------------\n\n\n#' Assert input is a matrix\n#'\n#' @param x An object\n#' @param msg A character string containing the error message to display if `x` is not a matrix\n#' @inheritParams common_roxygen_params\n#'\n#' @return invisible(TRUE) if `x` is a matrix, otherwise aborts with the error message specified by `msg`\n#'\n#' @examples\n#' try({\n#' assert_matrix(matrix(1:9, 3)) # Passes\n#' assert_matrix(matrix(1:9, 3, 3)) # Passes\n#' assert_matrix(c(1, 2, 3)) # Throws default error\n#' assert_matrix(1:10, \"Custom error message\") # Throws custom error\n#' })\n#'\n#' @concept assert_type\n#' @export\nassert_matrix <- assert_create(\n  func = is.matrix,\n  default_error_msg = msg_helper_assert_type(\"matrix\")\n)\n\n\n\n# Vector ------------------------------------------------------------------\n#' Assert input is a vector\n#'\n#' @param x An object\n#' @param msg A character string containing the error message to display if `x` is not a vector\n#' @inheritParams is_vector\n#' @inheritParams common_roxygen_params\n#' @return invisible(TRUE) if `x` is a vector, otherwise aborts with the error message specified by `msg`\n#'\n#' @note\n#' By default, lists are not considered vectors (i.e. `include_lists = FALSE`) to align with what end-users will expect, in spite of these objects technically being vectors.\n#'\n#' @examples\n#' try({\n#' assert_vector(c(1, 2, 3)) # Passes\n#' assert_vector(matrix(1:6, 2, 3)) # Throws default error message\n#' assert_vector(1:3) # Passes\n#'\n#' assert_vector(list(1, 2, 3)) # Throws default error message\n#' assert_vector(list(1, 2, 3), include_lists = TRUE) # Passes\n#'\n#' assert_vector(c(\"a\", 1, \"b\"), \"Custom error message\") # Throws custom error message\n#' assert_vector(factor(c(1, 2, 3)), \"Custom error message\") # Throws custom error message\n#' })\n#'\n#'\n#' @concept assert_type\n#' @export\nassert_vector <- assert_create(func = is_vector, msg_helper_assert_type(\"vector\"))\n\n\n# assert_vector <- function(x, msg = NULL, include_lists = FALSE, call = rlang::caller_env()) {\n#   string_argname <- deparse(substitute(x))\n#   if (!is_vector(x) || (inherits(x, what = \"list\") && !include_lists)) {\n#     if (is.null(msg)) {\n#       msg = \"'{.strong {string_argname}}' must be a vector, not a {class(x)}\"\n#     }\n#     cli::cli_abort(msg, call = call)\n#   }\n#   invisible(TRUE)\n# }\n\n# Numerics ----------------------------------------------------------------\n\n\n## factor -----------------------------------------------------------\n#' Assert input is a factor\n#'\n#' Assert an R object is a factor.\n#' Note that no assert_factor function exists since in R factors are always vector quantities (never scalar / in matrices)\n#'\n#' @param x An object\n#' @param msg A character string containing the error message to display if `x` is not a factor\n#' @inheritParams common_roxygen_params\n#'\n#' @return invisible(TRUE) if `x` is a factor, otherwise aborts with the error message specified by `msg`\n#'\n#' @examples\n#' try({\n#' assert_factor_vector(factor(c(\"a\", \"b\", \"c\"))) # Passes\n#' assert_factor_vector(c(\"a\", \"b\", \"c\")) # Throws default error\n#' assert_factor_vector(factor(c(\"a\", \"b\", \"c\")), \"Custom error message\") # Passes\n#' assert_factor_vector(1:3, \"Custom error message\") # Throws custom error\n#' })\n#'\n#' @details\n#' Technically this function name is misleading, since \\code{is.vector(factor(1)) == FALSE}\n#' but since they act exactly like vectors to end users, I think this name is the most suitable\n#'\n#'\n#' @concept assert_type\n#' @export\nassert_factor_vector <- assert_create(is.factor, default_error_msg = msg_helper_assert_type(\"factor\"))\n\n\n## numeric -----------------------------------------------------------\n#' Assert input is numeric\n#'\n#' Assert an R object is numeric\n#' Works for \\strong{vector} and \\strong{matrix} objects.\n#' To assert an object is specifically a \\strong{numeric vector} see [assert_numeric_vector()]\n#'\n#' @param x An object\n#' @param msg A character string containing the error message to display if `x` is not numeric\n#' @inheritParams common_roxygen_params\n#'\n#' @return invisible(TRUE) if `x` is numeric, otherwise aborts with the error message specified by `msg`\n#'\n#'\n#' @examples\n#' try({\n#' assert_numeric(1:3) # Passes\n#' assert_numeric(1.5:5.5) # Passes\n#' assert_numeric(c(\"a\", \"b\", \"c\")) # Throws default error\n#' assert_numeric(c(\"a\", 1, \"b\"), \"Custom error message\") # Throws custom error\n#' })\n#'\n#'\n#' @concept assert_type\n#' @export\nassert_numeric <- assert_create(is.numeric, default_error_msg = msg_helper_assert_type(\"numeric\", a = FALSE))\n\n## numeric vector -----------------------------------------------------------\n#' Assert input is a numeric vector\n#'\n#' @param x An object\n#' @param msg A character string containing the error message to display if `x` is not a numeric vector\n#' @inheritParams common_roxygen_params\n#' @inheritParams  is_numeric_vector\n#' @return invisible(TRUE) if `x` is a numeric vector, otherwise aborts with the error message specified by `msg`\n#'\n#'\n#'\n#' @concept assert_type\n#' @export\nassert_numeric_vector <- assert_create(is_numeric_vector, default_error_msg = msg_helper_assert_type(\"numeric vector\"))\n\n## number -----------------------------------------------------------\n#' Assert input is a number\n#'\n#' A number is a length 1 numeric vector.\n#' Numbers can be either integers or doubles.\n#'\n#' @param x An object\n#' @param msg A character string containing the error message to display if x is not a number\n#' @inheritParams common_roxygen_params\n#'\n#' @return invisible(TRUE) if x is a number, otherwise aborts with the error message specified by msg\n#'\n#' @examples\n#' assert_number(2) # Passes\n#' try({\n#' assert_number(c(2, 3)) # Throws default error\n#' assert_number(\"a\") # Throws default error\n#' assert_number(c(\"a\", 1, \"b\"), \"Custom error message\") # Throws custom error\n#' })\n#'\n#'\n#' @concept assert_type\n#' @export\nassert_number <- assert_create_chain(\n  assert_create(is.numeric, \"'{.strong {arg_name}}' is not a number! (class is {.strong {class(arg_value)}}, not numeric)\"),\n  assert_create(is_scalar, \"'{.strong {arg_name}}' is not a number! (length is {.strong {length(arg_value)}}, not 1)\")\n)\n\n\n#' Assert input is an integer\n#'\n#' @param x An object\n#' @param msg A character string containing the error message to display if `x` is not an integer\n#' @inheritParams common_roxygen_params\n#'\n#' @return invisible(TRUE) if `x` is an integer, otherwise aborts with the error message specified by `msg`\n#'\n#' @note\n#' In R, integers are whole numbers.\n#' Both integers and doubles (numbers with decimals) are considered numeric.\n#' This function checks that `x` specifically belong to the integer class.\n#'\n#' @examples\n#' try({\n#' assert_int(1) # Passes\n#' assert_int(1:10) # Passes\n#' assert_int(c(1, 2, 3)) # Passes\n#' assert_int(\"a\") # Throws default error\n#' assert_int(1.5, msg = \"Custom error message\") # Throws custom error\n#' })\n#'\n#'\n#' @concept assert_type\n#' @export\nassert_int <- assert_create(is.integer, msg_helper_assert_type(\"integer\", an = TRUE))\n\n\n# Logicals ----------------------------------------------------------------\n\n## logical -----------------------------------------------------------\n#' Assert input is logical\n#'\n#' Assert an R object is 'logical' (TRUE/FALSE).\n#' Works for \\strong{vector} and \\strong{matrix} objects.\n#' To assert an object is specifically a \\strong{logical vector} see [assert_logical_vector()]\n#'\n#' @param x An object\n#' @param msg A character string containing the error message to display if `x` is not logical\n#' @inheritParams common_roxygen_params\n#'\n#' @return invisible(TRUE) if `x` is logical, otherwise aborts with the error message specified by `msg`\n#'\n#' @examples\n#' try({\n#' assert_logical(TRUE) # Passes\n#' assert_logical(c(TRUE, FALSE, TRUE)) # Passes\n#' assert_logical(c(\"a\", \"b\")) # Throws default error\n#' assert_logical(1:3, \"Custom error message\") # Throws custom error\n#' })\n#'\n#'\n#'\n#' @concept assert_type\n#' @export\nassert_logical <- assert_create(is.logical, msg_helper_assert_type(\"logical\", a = FALSE))\n\n\n## logical vector -----------------------------------------------------------\n#' Assert input is an atomic logical vector\n#'\n#'\n#'\n#' @param x An object\n#' @param msg A character string containing the error message to display if x is not an atomic logical vector\n#' @inheritParams common_roxygen_params\n#' @inheritParams is_logical_vector\n#' @return invisible(TRUE) if x is an atomic logical vector, otherwise aborts with the error message specified by msg\n#'\n#' @examples\n#' try({\n#' assert_logical_vector(c(TRUE, TRUE, TRUE)) # Passes\n#' assert_logical_vector(\"a\") # Throws default error\n#' assert_logical_vector(c(1, 0, 1), \"Custom error message\") # Throws custom error\n#' })\n#'\n#'\n#' @concept assert_type\n#' @export\nassert_logical_vector <- assert_create(is_logical_vector, msg_helper_assert_type(\"logical vector\"))\n\n\n## flag -----------------------------------------------------------\n#' Assert input is a scalar logical\n#'\n#' Assert input is a flag (a logical of length 1: `TRUE` or `FALSE`)\n#'\n#' @param x An object\n#' @param msg A character string containing the error message to display if `x` is not a scalar logical\n#' @inheritParams common_roxygen_params\n#' @return invisible(TRUE) if `x` is a scalar logical, otherwise aborts with the error message specified by `msg`\n#'\n#' @examples\n#' try({\n#' assert_flag(TRUE) # Passes\n#' assert_flag(FALSE) # Passes\n#' assert_flag(c(TRUE, FALSE)) # Throws default error\n#' assert_flag(1, \"Custom error message\") # Throws custom error\n#' })\n#'\n#'\n#' @concept assert_type\n#' @export\nassert_flag <- assert_create_chain(\n  assert_create(is.logical, \"'{.strong {arg_name}}' is not a flag! (class is {.strong {class(arg_value)}}, not logical)\"),\n  assert_create(is_scalar, \"'{.strong {arg_name}}' is not a flag! (length is {.strong {length(arg_value)}}, not 1)\")\n)\n\n\n# Characters --------------------------------------------------------------\n\n## character -----------------------------------------------------------\n#' Assert input is a character vector\n#'\n#' Assert an R object is a 'character' type.\n#' Works for \\strong{vector} and \\strong{matrix} objects.\n#' To assert an object is specifically a \\strong{character vector} see [assert_character_vector()]\n#'\n#' @param x An object\n#' @param msg A character string containing the error message to display if `x` is not a character vector\n#' @inheritParams common_roxygen_params\n#'\n#' @return invisible(TRUE) if `x` is a character vector, otherwise aborts with the error message specified by `msg`\n#'\n#' @examples\n#' try({\n#' assert_character(\"a\") # Passes\n#' assert_character(\"a\") # Passes\n#' assert_character(c(\"a\", \"b\", \"c\")) # Passes\n#' assert_character(matrix(c('A', 'B', 'C', 'D')))  # Passes\n#' assert_character(1:3) # Throws default error\n#' assert_character(c(\"a\", 1, \"b\"), \"Custom error message\") # Throws custom error\n#' })\n#'\n#'\n#' @concept assert_type\n#' @export\nassert_character <- assert_create(is.character, msg_helper_assert_type(\"character\"))\n\n## character vector -----------------------------------------------------------\n#' Assert input is a character vector\n#'\n#' Assert an object is a character vector. Length 1 character vectors (strings) are considered vectors.\n#'\n#' @param x An object\n#' @param msg A character string containing the error message to display if `x` is not a character vector\n#' @inheritParams common_roxygen_params\n#' @inheritParams is_character_vector\n#' @return invisible(TRUE) if `x` is a character vector, otherwise aborts with the error message specified by `msg`\n#'\n#' @examples\n#' try({\n#' assert_character_vector(c(\"a\", \"b\", \"c\")) # Passes\n#' assert_character_vector(c(\"a\", 1, \"b\")) # Throws default error\n#' assert_character_vector(matrix(c('A', 'B', 'C', 'D')))  # Throws error since type = matrix\n#' assert_character_vector(c(\"a\", 1, \"b\"), \"Custom error message\") # Throws custom error\n#' assert_character_vector(glue::glue('A')) # Throws error\n#' })\n#'\n#'\n#' @concept assert_type\n#' @export\nassert_character_vector <- assert_create(is_character_vector, msg_helper_assert_type(\"character vector\"))\n\n## character vector or glue -----------------------------------------------------------\n#' Assert input is a character vector / glue vector\n#'\n#' Assert an object is a character vector (or a glue vector). Length 1 character vectors (strings) are considered vectors.\n#'\n#' @param x An object\n#' @param msg A character string containing the error message to display if `x` is not a character vector\n#' @inheritParams common_roxygen_params\n#' @inheritParams is_character_vector\n#' @return invisible(TRUE) if `x` is a character vector, otherwise aborts with the error message specified by `msg`\n#'\n#' @examples\n#' try({\n#' assert_character_vector_or_glue(c(\"a\", \"b\", \"c\")) # Passes\n#' assert_character_vector_or_glue(glue::glue('A')) # Passes\n#' assert_character_vector_or_glue(c(\"a\", 1, \"b\")) # Throws default error\n#' assert_character_vector_or_glue(matrix(c('A', 'B', 'C', 'D')))  # Throws error since type = matrix\n#' assert_character_vector_or_glue(c(\"a\", 1, \"b\"), \"Custom error message\") # Throws custom error\n#' })\n#'\n#'\n#' @concept assert_type\n#' @export\nassert_character_vector_or_glue <- assert_create(is_character_vector_or_glue, msg_helper_assert_type(\"character vector\"))\n\n## string -----------------------------------------------------------\n#' Assert input is a character string\n#'\n#' @param x An object\n#' @param msg A character string containing the error message to display if x is not a string\n#' @inheritParams common_roxygen_params\n#'\n#' @return invisible(TRUE) if x is a string, otherwise aborts with the error message specified by msg\n#'\n#' @examples\n#' try({\n#' assert_string(\"a\") # Passes\n#' assert_string(c(\"a\", \"b\", \"c\")) # Throws default error\n#' assert_string(1:3) # Throws default error\n#' assert_string(c(\"a\", 1, \"b\"), \"Custom error message\") # Throws custom error\n#' })\n#'\n#'\n#' @concept assert_type\n#' @export\nassert_string <- assert_create_chain(\n  assert_create(is.character, \"'{.strong {arg_name}}' is not a string! (class is {.strong {class(arg_value)}}, not character)\"),\n  assert_create(is_scalar, \"'{.strong {arg_name}}' is not a string! (length is {.strong {length(arg_value)}}, not 1)\")\n  )\n\n#' Assert input is a  non empty character string\n#'\n#' Asserts input is a string, and nonempty (i.e. not equal to '')\n#'\n#' @param x An object\n#' @param msg A character string containing the error message to display if x is not a\n#' @inheritParams common_roxygen_params\n#'\n#' @return invisible(TRUE) if x is a character vector, otherwise aborts with the error message specified by msg\n#'\n#' @examples\n#' try({\n#' assert_non_empty_string(\"a\") # Passes\n#' assert_non_empty_string(\"\") # Fails\n#' })\n#'\n#'\n#' @concept assert_type\n#' @export\nassert_non_empty_string <- assert_create(\n    func = is_non_empty_string_advanced\n  )\n\n\n# Functions ---------------------------------------------------------------\n\n## function ----------------------------------------------------------------\n#' Assert input is a function\n#'\n#' @param x An object\n#' @param msg A character string containing the error message to display if `x` is not a function\n#' @inheritParams common_roxygen_params\n#'\n#' @return invisible(TRUE) if `x` is a function, otherwise aborts with the error message specified by `msg`\n#'\n#' @examples\n#' try({\n#' # Assert that a variable is a function\n#' x <- function(a, b) { a + b }\n#' assert_function(x)  # does nothing\n#'\n#' # Assert that a variable is not a function\n#' x <- \"not a function\"\n#' assert_function(x)  # stops execution and prints an error message\n#' })\n#'\n#'\n#' @concept assert_type\n#' @export\nassert_function <- assert_create(is.function, msg_helper_assert_type(expected_type = \"function\"))\n\n\n\n# Lists -------------------------------------------------------------------\n\n#' Assert input is a list\n#'\n#' @param x An object\n#' @param msg A character string containing the error message to display if `x` is not a list\n#' @inheritParams common_roxygen_params\n#' @inheritParams is_list\n#' @return invisible(TRUE) if `x` is a list, otherwise aborts with the error message specified by `msg`\n#'\n#' @examples\n#' try({\n#' # Assert that a variable is a list\n#' x <- list(1, 2, 3)\n#' assert_list(x)  # does nothing\n#'\n#' # Assert that a variable is not a list\n#' x <- \"not a list\"\n#' assert_list(x)  # stops execution and prints an error message\n#' })\n#'\n#' @concept assert_type\n#' @export\nassert_list <- assert_create(is_list, msg_helper_assert_type(expected_type = \"list\"))\n\n#' Assert that x is reactive\n#'\n#' @param x An object\n#' @param msg A character string containing the error message to display if `x` is not reactive\n#' @inheritParams common_roxygen_params\n#' @inheritParams is_list\n#' @return invisible(TRUE) if `x` is a reactive, otherwise aborts with the error message specified by `msg`\n#'\n#' @examples\n#' try({\n#' # Assert that a variable is reactive\n#' x <- shiny::reactive(1)\n#' assert_reactive(x)  # does nothing\n#'\n#' # Assert that a variable is not a list\n#' x <- 1\n#' assert_reactive(x)  # stops execution and prints an error message\n#' })\n#'\n#' @concept assert_type\n#' @export\nassert_reactive <- assert_create(func = is_reactive, default_error_msg = msg_helper_assert_type(expected_type = \"reactive\"))\n\n\n## Scalar -----------------------------------------------------------\n#' Assert input is a scalar\n#'\n#' Assert that an object is a scalar, meaning it is a length 1 atomic vector (such as \\code{numeric(1)}, \\code{character(1)} or \\code{logical(1)}).\n#' Note lists, data.frames and matrices are never considered scalar objects, even if they have only one element.\n#'\n#' @param x An object\n#' @param msg A character string containing the error message to display if `x` is not a scalar\n#' @inheritParams common_roxygen_params\n#'\n#' @return invisible(TRUE) if `x` is a scalar, otherwise aborts with the error message specified by `msg`\n#'\n#' @examples\n#'\n#' # Pass when value is scalar\n#' assert_scalar(5) # Passes\n#' assert_scalar(\"single string\") # Passes\n#' assert_scalar(TRUE) # Passes\n#'\n#' # Fail when value is not\n#' try({\n#' assert_scalar(c(1, 2, 3)) # Throws default error\n#' assert_scalar(matrix(1:4, 2, 2)) # Throws default error\n#' })\n#'\n#'\n#' @concept assert_type\n#' @export\nassert_scalar <- assert_create(\n  func = is_scalar,\n  default_error_msg = msg_helper_assert_type(\"scalar\")\n)\n\n# Connections -----------------------------------------------------------------\n\n#' Assert input is a database connection\n#'\n#' Assert the input object is a database connection, specifically of the \"DBIConnection\" class,\n#' which is the standard virtual class used by the DBI package for database connections.\n#' Note this assertion does not test if the database connection is valid and/or active.\n#'\n#' @param x An object to assert is a database connection\n#' @param msg A custom error message displayed if `x` is not a valid database connection.\n#' @inheritParams common_roxygen_params\n#'\n#' @return `invisible(TRUE)` if `x` is a valid database connection, otherwise aborts with an error message.\n#'\n#' @examples\n#' try({\n#'   # Assuming a valid DBI connection `conn`:\n#'   assert_connection(conn) # Passes if `conn` is a DBI connection\n#'\n#'   assert_connection(42) # Fails with error message\n#' })\n#'\n#' @details\n#' This function is designed for use with objects inheriting from the \"DBIConnection\" class, which is used widely across database connection implementations in R.\n#' As other database interface packages are introduced, additional checks may be added to support other connection classes.\n#'\n#' @concept assert_type\n#' @export\nassert_connection <- assert_create(\n  func = is_connection,\n  default_error_msg = msg_helper_assert_type(\"database connection\")\n)\n\n","type":"text"},{"name":"assertions/coverage_testing.R","content":"# These functions are for counting the number of tests per assertion\n# and updating the json used to display the relevant badge\n\n#' List assertion names\n#'\n#' List all assertion names\n#'\n#' @param exclude_create_and_chain exclude assert_create and assert_create_chain (flag)\n#'\n#' @return unique set of assertion names (character)\n#'\nassertion_names <- function(exclude_create_and_chain =TRUE){\n\n  # Get path to scripts\n  path_r_directory <- system.file(\"R\", package = \"assertions\")\n  path_scripts=dir(path_r_directory, full.names = TRUE, pattern = \".R$\")\n\n  # Get list of assertions\n  ## Read lines\n  char_lines <- unlist(lapply(path_scripts, function(path) {readLines(path)}))\n  char_lines <- gsub(x=char_lines, pattern = \" \", replacement = \"\")\n\n  ## Find assertions\n  assertions_names <-\n    char_lines[\n      grepl(x=char_lines, pattern = \"^assert_[a-zA-Z0-9_]+\") &\n        grepl(x=char_lines, pattern = \"(assert_create|assert_create_chain)\") &\n        !grepl(x=char_lines, pattern = \"^#\")\n      ]\n\n  assertions_names <- sub(x=assertions_names, pattern = \"(<-|=|\\\\().*\", replacement = \"\")\n  assertions_names <- unique(assertions_names)\n  assertions_names <- sort(assertions_names)\n\n  if(exclude_create_and_chain){\n    assertions_names <- assertions_names[!assertions_names %in% c('assert_create', 'assert_create_chain')]\n  }\n\n  assertions_names <- assertions_names[!assertions_names %in% c('assert_create_chain_example')]\n\n\n  return(assertions_names)\n}\n\n\n#' Count tests per Assertion\n#'\n#' Count the number of unit-tests per assertion.\n#' Note assertion_tests only finds tests where `expect_` and `assert_` are on the same line.\n#'\n#'\n#' @return two column data.frame describing assertion name and number of tests (expect_statement)\n#'\nassertion_tests <- function(){\n  #message(\"Warning: assertion_tests only finds tests where `expect_` and `assert_` are on the same line\")\n  path_r_directory <- testthat::test_path()\n  path_scripts=dir(path_r_directory, full.names = TRUE, pattern = \".R$\")\n\n\n  ## Read all test lines\n  char_lines <- unlist(lapply(path_scripts, function(path) {readLines(path)}))\n  char_lines <- gsub(x=char_lines, pattern = \" \", replacement = \"\")\n  #char_lines <- gsub(x=char_lines, pattern = \"^[ \\t]?\\n\", replacement = \"\")\n  #char_lines <- collapse_function_calls(char_lines)\n\n  expect_lines = char_lines[\n    grepl(x=char_lines, pattern = \"^expect_[a-zA-Z0-9_]+\") &\n      grepl(x=char_lines, pattern = \"assert_\")\n    ]\n\n  tested_assertion = sub(x=expect_lines, \".*(assert_[a-zA-Z0-9_]+()).*\", \"\\\\1\")\n\n\n  df_assertion_test_counts <- as.data.frame(table(tested_assertion))\n  names(df_assertion_test_counts) <- c(\"assertion\", \"tests\")\n  df_assertion_test_counts <- df_assertion_test_counts[df_assertion_test_counts[[\"assertion\"]] %in% assertion_names(),]\n\n\n  assertion_names <- assertion_names()\n  assertions_missing_tests <- assertion_names[!assertion_names %in% df_assertion_test_counts[[\"assertion\"]]]\n\n  df_assertion_test_counts <- rbind(\n    df_assertion_test_counts,\n    data.frame(assertion = assertions_missing_tests, tests = rep(0, times = length(assertions_missing_tests)))\n  )\n\n  df_assertion_test_counts <- df_assertion_test_counts[order(df_assertion_test_counts[[\"tests\"]], decreasing = TRUE),]\n\n  return(df_assertion_test_counts)\n}\n\n#' Check assertions are tested enough\n#'\n#' @param min_required_tests min number of tests (expect statements) per assertion\n#'\n#' @return TRUE if all assertions sufficiently tested. Otherwise throws error\n#'\ncheck_all_assertions_are_tested_enough <- function(min_required_tests = 5){\n\n  undertested_assertions <- assertion_tests()[assertion_tests()[[\"tests\"]] < min_required_tests,][[\"assertion\"]]\n\n  if(length(undertested_assertions) == 0)\n    return(TRUE)\n\n  stop(paste0(\"The following assertions have too few unit tests (< \",min_required_tests,\"): \", paste0(undertested_assertions, collapse = \", \")))\n}\n","type":"text"},{"name":"assertions/export_testing.R","content":"exported_functions <- function(){\n  exports <- readLines(system.file(\"NAMESPACE\", package = \"assertions\"))\n  exports <- exports[exports != \"\"]\n  exports <- exports[!startsWith(exports, prefix = \"#\")]\n  exports <- sub(x=exports, pattern = \"export\\\\((.*)\\\\)\", replacement = \"\\\\1\")\n  return(exports)\n}\n\nall_exports_are_assertions <- function(exceptions = \"assert\"){\n\n  exports <- exported_functions()\n  non_assertion_exports <- exports[!grepl(pattern = \"^assert_\", x = exports)]\n\n  non_assertion_exports <- non_assertion_exports[!non_assertion_exports %in% exceptions]\n\n  if(length(non_assertion_exports) == 0) return(TRUE)\n  else{\n    stop('Exporting functions that are NOT assertions: \\n', paste0('   > ' , non_assertion_exports, '\\n'))\n  }\n}\n","type":"text"},{"name":"assertions/has.R","content":"# Has Functions -----------------------------------------------------------\n\n#' Check if a vector has duplicates\n#'\n#' This function returns a logical value indicating whether the input vector contains\n#' duplicated elements.\n#'\n#' @param x A vector.\n#' @return A logical value indicating whether the input vector contains duplicated elements.\n#' @examples\n#' if(interactive()){\n#' has_duplicates(c(1, 2, 3))  # returns FALSE\n#' has_duplicates(c(1, 2, 2))  # returns TRUE\n#' }\nhas_duplicates <- function(x){\n  anyDuplicated(x) != 0\n}\n\n#' Check if a vector has no duplicates\n#'\n#' This function returns a logical value indicating whether the input vector contains\n#' no duplicated elements.\n#'\n#' @param x A vector.\n#' @return A logical value indicating whether the input vector contains no duplicated elements.\n#' @examples\n#' if(interactive()){\n#' has_no_duplicates(c(1, 2, 3))  # returns TRUE\n#' has_no_duplicates(c(1, 2, 2))  # returns FALSE\n#' }\nhas_no_duplicates <- function(x){\n  !has_duplicates(x)\n}\n\n#' Check if a vector has missing values\n#'\n#' This function returns a logical value indicating whether the input vector contains\n#' missing values (`NA`).\n#'\n#' @param x A vector.\n#' @return A logical value indicating whether the input vector contains missing values.\n#' @examples\n#' if(interactive()){\n#' has_missing_values(c(1, 2, 3))  # returns FALSE\n#' has_missing_values(c(1, NA, 2))  # returns TRUE\n#' }\nhas_missing_values <- function(x){\n  anyNA(x)\n}\n\n#' Check if a vector has no missing values\n#'\n#' This function returns a logical value indicating whether the input vector contains\n#' no missing values (`NA`).\n#'\n#' @param x A vector.\n#' @return A logical value indicating whether the input vector contains no missing values.\n#' @examples\n#' if(interactive()){\n#' has_no_missing_values(c(1, 2, 3))  # returns TRUE\n#' has_no_missing_values(c(1, NA, 2))  # returns FALSE\n#' }\nhas_no_missing_values <- function(x){\n  !has_missing_values(x)\n}\n\n# Utils -------------------------------------------------------------------\n#' Count the number of missing values in a vector\n#'\n#' This function returns the number of missing values (`NA`) in the input vector.\n#'\n#' @param x A vector.\n#' @return The number of missing values in the input vector.\n#' @examples\n#' if(interactive()){\n#' util_count_missing(c(1, 2, 3))  # returns 0\n#' util_count_missing(c(1, NA, 2))  # returns 1\n#' }\nutil_count_missing <- function(x){\n  sum(is.na(x))\n}\n\n#' Count the number of duplicated values in a vector\n#'\n#' This function returns the number of duplicated values in the input vector.\n#'\n#' @param x A vector.\n#' @return The number of duplicated values in the input vector.\n#' @examples\n#' if(interactive()) {\n#' util_count_duplicates(c(1, 2, 2))  # returns 1\n#' util_count_duplicates(c(1, 2, 3))  # returns 0\n#' }\nutil_count_duplicates <- function(x){\n  sum(duplicated(x))\n}\n\n#' Get the duplicated values in a vector\n#'\n#' This function returns a vector of the duplicated values in the input vector.\n#'\n#' @param x A vector.\n#' @return A vector of the duplicated values in the input vector.\n#' @examples\n#' if(interactive()) {\n#' util_get_duplicated_values(c(1, 2, 2))  # returns 2\n#' util_get_duplicated_values(c(1, 2, 3))  # returns NULL\n#' }\nutil_get_duplicated_values <- function(x){\n  unique(x[duplicated(x)])\n}\n\n\n#' Check object is some class\n#'\n#' This function checks whether object is a specific class\n#'\n#' @param x A value to check.\n#' @param class checks if `x` belongs to `class`. If multiple values of `class` are supplied, returns whether `x` belongs to any of them (character)\n#' @return A logical scalar indicating `x` belongs to `class`\n#' @examples\n#' if(interactive()) {\n#'   has_class(1, \"numeric\") # TRUE\n#'   has_class(1, \"character\") # FALSE\n#' }\n#' @concept is_type\n#'\nhas_class <- function(x, class){\n  return(inherits(x, what = class))\n}\n\n\n# Assertions --------------------------------------------------------------\n#' Assert that the input vector has no missing values\n#'\n#' This function asserts that the input vector has no missing values (`NA`) and aborts\n#' with an error message if it does.\n#'\n#' @param x A vector.\n#' @param msg A character string containing the error message to display if `x` has missing values.\n#' @inheritParams common_roxygen_params\n#'\n#' @return invisible(TRUE) if `x` has no missing values (NA), otherwise aborts with the error message specified by `msg`\n#'\n#' @examples\n#' try({\n#' assert_no_missing(c(1, 2, 3))  # Passes\n#' assert_no_missing(c(1, NA, 2))  # Throws default error\n#'\n#' assert_no_missing(c(1, 2, 3), msg = \"Custom error message\")  # Passes\n#' assert_no_missing(c(1, NA, 2), msg = \"Custom error message\")  # Throws custom error\n#' })\n#'\n#' @concept assert_has\n#' @export\nassert_no_missing <- assert_create(\n  has_no_missing_values,\n  default_error_msg = \"'{.strong {arg_name}}' must have {.strong no missing values}! Found {.strong {util_count_missing(arg_value)}}\"\n)\n\n\n\n\n#' Assert that the input vector has no duplicates\n#'\n#' Assert the input vector has no duplicated elements\n#'\n#' @param x A vector.\n#' @param msg A character string containing the error message to display if `x` has duplicates.\n#' @inheritParams common_roxygen_params\n#'\n#' @return invisible(TRUE) if `x` has no duplicates, otherwise aborts with the error message specified by `msg`\n#'\n#' @examples\n#' try({\n#' assert_no_duplicates(c(1, 2, 3))  # Passes\n#' assert_no_duplicates(c(1, 2, 2))  # Throws default error\n#'\n#' assert_no_duplicates(c(1, 2, 3), msg = \"Custom error message\")  # Passes\n#' assert_no_duplicates(c(1, 2, 2), msg = \"Custom error message\")  # Throws custom error\n#' })\n#'\n#' @concept assert_has\n#' @export\nassert_no_duplicates <- assert_create(\n  has_no_duplicates,\n  \"'{.strong {arg_name}}' must have {.strong no duplicates}! Found {.strong {util_count_duplicates(arg_value)}} duplicated value{?s}: {.emph {util_get_duplicated_values(arg_value)}}\"\n)\n\n\n#' Assert object belongs to class\n#'\n#' This function asserts that the input object belongs to `class`\n#'\n#' @param x An input object\n#' @param msg A character string containing the error message to display if `x` does not belong to `class`\n#' @inheritParams common_roxygen_params\n#' @inheritParams has_class\n#' @return invisible(TRUE) if `x` belongs to `class`, otherwise aborts with the error message specified by `msg`\n#'\n#' @examples\n#' try({\n#' assert_has_class(1, \"numeric\")  # Passes\n#' assert_has_class(1, \"character\")  # Throws default error\n#' })\n#'\n#' @concept assert_has\n#' @export\nassert_class <- assert_create(\n  has_class,\n  \"'{.strong {arg_name}}' must belong to class {.strong '{class}'}, not {.strong {class(arg_value)}}\"\n)\n","type":"text"},{"name":"assertions/is_comparisons.R","content":"# Comparisons -------------------------------------------------------------\n\n# Engine\ncompare <- function(x, equal_to = NULL, minimum = NULL, maximum = NULL, comparison_inclusive = TRUE, all_must_satisfy = TRUE){\n\n  # Check at least one comparison criterion is supplied\n  if(is.null(minimum) && is.null(maximum) && is.null(equal_to))\n    stop(\"Must supply at least one threshold: either 'equal_to', `minimum` or maximum\")\n\n  # Assert no missing values\n  assert_no_missing(x, arg_name = deparse(substitute(x, env = parent.frame())))\n\n  # Preset some vals\n  passes_min_threshold = TRUE\n  passes_max_threshold = TRUE\n  passes_equivalence = TRUE\n\n\n  # Is Greater Than\n  if(!is.null(minimum)){\n    if(comparison_inclusive) passes_min_threshold <- x >= minimum\n    else passes_min_threshold <- x > minimum\n    passes_min_threshold <- if(all_must_satisfy) all(passes_min_threshold) else any(passes_min_threshold)\n  }\n\n\n  # Is Less Than\n  if(!is.null(maximum)) {\n    if(comparison_inclusive) passes_max_threshold <- x <= maximum\n    else passes_max_threshold <- x < maximum\n\n    passes_max_threshold <- if(all_must_satisfy) all(passes_max_threshold) else any(passes_max_threshold)\n  }\n\n  # Is Equal To\n  if(!is.null(equal_to)){\n    passes_equivalence <- x == equal_to\n    passes_equivalence <- if(all_must_satisfy) all(passes_equivalence) else any(passes_equivalence)\n  }\n\n  # Passes thresholds\n  passes_all_thresholds <- passes_min_threshold && passes_max_threshold && passes_equivalence\n\n  return(passes_all_thresholds)\n}\n\n\n#' Check if a numeric vector is greater than a specified minimum value\n#'\n#' This function checks if a numeric vector is greater than a specified minimum value. It can also optionally check if all elements of the vector must be greater than the minimum value or if only one element is sufficient\n#'\n#' @param x a numeric vector to check\n#' @param minimum The minimum value to compare against\n#'\n#' @return A logical value indicating whether all elements of the numeric vector x are greater than the specified minimum value\n#' @examples\n#' if(interactive()){\n#' is_greater_than(c(2,3,4), 1) # TRUE\n#' is_greater_than(c(2,3,4), 2) # TRUE\n#' is_greater_than(c(2,3,1), 3) # FALSE\n#' }\nis_greater_than <- function(x, minimum){\n  compare(x = x, minimum = minimum, all_must_satisfy = TRUE, comparison_inclusive = FALSE)\n}\n\n#' Check if a numeric vector is greater than or equal to a specified minimum value\n#'\n#' This function checks if a numeric vector is greater than or equal to a specified minimum value. It can also optionally check if all elements of the vector must be greater than or equal to the minimum value or if only one element is sufficient\n#'\n#' @param x a numeric vector to check\n#' @param minimum The minimum value to compare against\n#' @return A logical value indicating whether all elements of the numeric vector x are greater than or equal to the specified minimum value\n#' @examples\n#' if(interactive()){\n#' is_greater_than_or_equal_to(c(2,3,4), 1) # TRUE\n#' is_greater_than_or_equal_to(c(2,3,4), 2) # TRUE\n#' is_greater_than_or_equal_to(c(2,3,1), 3) # FALSE\n#' }\nis_greater_than_or_equal_to <- function(x, minimum){\n  compare(x = x, minimum = minimum, all_must_satisfy = TRUE, comparison_inclusive = TRUE)\n}\n\n#' Check if a numeric vector is less than a specified maximum value\n#'\n#' This function checks if a numeric vector is less than a specified maximum value. It can also optionally check if all elements of the vector must be less than the maximum value or if only one element is sufficient\n#'\n#' @param x a numeric vector to check\n#' @param maximum The maximum value to compare against\n#'\n#' @return A logical value indicating whether all elements of the numeric vector x are less than the specified maximum value\n#' @examples\n#' if(interactive()){\n#' is_less_than(c(1,2,3), 4) # TRUE\n#' is_less_than(c(1,2,3), 2) # FALSE\n#' is_less_than(c(1,2,4), 3) # FALSE\n#' }\nis_less_than <- function(x, maximum){\n  compare(x = x, maximum = maximum, all_must_satisfy = TRUE, comparison_inclusive = FALSE)\n}\n\n#' Check if a numeric vector is less than or equal to a specified maximum value\n#'\n#' This function checks if a numeric vector is less than or equal to a specified maximum value. It can also optionally check if all elements of the vector must be less than or equal to the maximum value or if only one element is sufficient\n#'\n#' @param x a numeric vector to check\n#' @param maximum The maximum value to compare against\n#' @return A logical value indicating whether all elements of the numeric vector x are less than or equal to the specified maximum value\n#' @examples\n#' if(interactive()){\n#' is_less_than_or_equal_to(c(1,2,3), 4) # TRUE\n#' is_less_than_or_equal_to(c(1,2,3), 3) # TRUE\n#' is_less_than_or_equal_to(c(1,2,4), 3) # FALSE\n#' }\nis_less_than_or_equal_to <- function(x, maximum){\n  compare(x = x, maximum = maximum, all_must_satisfy = TRUE, comparison_inclusive = TRUE)\n}\n\n#' Check if two objects are identical\n#'\n#' @param x first object to compare\n#' @param y second object to compare\n#' @return logical value indicating whether or not the objects are identical\nis_identical <- function(x, y){\n  identical(x = x, y = y)\n}\n\n#' Check equality of two objects\n#'\n#' Is `x` equal to `y`. powered by the [all.equal()] function.\n#'\n#' @param x first object to compare\n#' @param y second object to compare\n#' @param tolerance Differences smaller than tolerance are not reported. The default value is close to 1.5e-8 (numeric >= 0).\n#' @param check_names should the names(.) of target and current should be compare (flag)\n#' @param check_environment should the environments of functions should be compared?\n#' You may need to set check.environment=FALSE in unexpected cases, such as when comparing two nls() fits. (flag)\n#' @param check_tzone should  \"tzone\" attributes be compared. Important for comparing POSIXt objects. (flag)\n#' @return TRUE if x is equal to y\n#'\n#' @examples\n#' if(interactive()){\n#' is_equal(1, 1) #TRUE\n#' is_equal(c(1, 2), 1) #FALSE\n#'\n#' is_equal(c(\"A\", \"B\"), c(\"A\", \"B\")) #TRUE\n#' is_equal(\"A\", \"B\") #FALSE\n#' }\nis_equal <- function(x, y, tolerance = sqrt(.Machine$double.eps), check_names = TRUE, check_environment = TRUE, check_tzone = TRUE){\n  isTRUE(all.equal(x, y, check.names = check_names, check.environment = check_environment, check.tzone = check_tzone))\n}\n\n\n#' Check equality of type\n#'\n#' Is type of `x` the same as `y` (according to typof)\n#'\n#' @param x first object to compare\n#' @param y second object to compare\n#'\n#' @return TRUE if x and y are of the same type, otherwise FALSE\n#'\nis_same_type <- function(x, y){\n  typeof(x) == typeof(y)\n}\n","type":"text"},{"name":"assertions/is_functions.R","content":"\n# Basic Typing -------------------------------------------------------------------\n\n#' Check if an object is a vector\n#' This function checks if an object is a vector\n#'\n#' @param x An object to check\n#' @return A logical indicating whether `x` is a vector\n#'\n#'\n#' @concept is_type\n#'\nis_vector <- function(x){\n  is.vector(x) && (!inherits(x, what = \"list\"))\n}\n\n#' Check if an object is a numeric vector\n#'\n#' This function checks if an object is a numeric vector in R.\n#'\n#' @param x An object to check.\n#' @return A logical value indicating whether `x` is a numeric vector.\n#' @examples\n#' if(interactive()){\n#' is_numeric_vector(c(1, 2, 3)) # TRUE\n#' is_numeric_vector(list(1, 2, 3)) # FALSE\n#' is_numeric_vector(1:5) # TRUE\n#' is_numeric_vector(\"hello\") # FALSE\n#' is_numeric_vector(list(1, 2, \"a\")) # FALSE\n#' }\n#'\n#' @concept is_type\n#'\nis_numeric_vector <- function(x){\n  is.numeric(x) && is_vector(x)\n}\n\n\n#' Check if an object is a single number\n#'\n#' @param x An object to check.\n#' @return A logical value indicating whether `x` is a single number.\n#'\n#' @concept is_type\n#'\nis_number <- function(x){\n  is.numeric(x) && length(x) == 1\n}\n\n#' Check if an object is a character vector\n#'\n#' @param x An object to check.\n#' @return A logical value indicating whether `x` is a character vector.\n#'\n#' @concept is_type\nis_character_vector <- function(x){\n  is.character(x) && is_vector(x)\n}\n\n#' Check if an object is a character vector\n#'\n#' Differs from [is_character_vector()] in that it permits glue character vectors to pass.\n#'\n#' @param x An object to check.\n#' @return A logical value indicating whether `x` is a character vector or glue vector.\n#'\n#' @concept is_type\nis_character_vector_or_glue <- function(x){\n  is.character(x) && (is_vector(x) | has_class(x, 'glue'))\n}\n\nis_scalar <- function(x){\n length(x) == 1 & typeof(x) != \"list\" & !any(class(x) %in% c(\"matrix\"))\n}\n\n#' Check if an object is a logical vector\n#'\n#' @param x An object to check.\n#' @return A logical value indicating whether `x` is a logical vector.\n#'\n#' @concept is_type\nis_logical_vector <- function(x){\n  is.logical(x) && is_vector(x)\n}\n\n#' Check if an object is a single string\n#'\n#' @param x An object to check.\n#' @return A logical value indicating whether `x` is a single string.\n#'\n#' @concept is_type\nis_string <- function(x){\n  is.character(x) && length(x) == 1\n}\n\n#' Check if a value is a logical flag\n#'\n#' This function checks if a value is a logical scalar (i.e., a single logical value).\n#'\n#' @param x A value to check.\n#' @return A logical scalar indicating whether `x` is a logical flag.\n#'\n#' @concept is_type\n#'\nis_flag <- function(x){\n  is.logical(x) && length(x) == 1\n}\n\n#' Check if a value is a list\n#'\n#' This function checks if a value is a list.\n#' By default, definition of a 'list' excludes data.frames in spite of them technically being lists.\n#' This behaviour can be changed by setting `include_dataframes = TRUE`\n#'\n#' @param x A value to check.\n#' @param include_dataframes A logical indicating whether data_frames should be considered vectors. Default is `FALSE`.\n#' @return A logical scalar indicating whether `x` is a list.\n#' @examples\n#' if(interactive()){\n#' is_list(list(1, 2)) # TRUE\n#' is_list(c(1, 2, 3)) # FALSE\n#' is_list(data.frame()) # FALSE\n#' is_list(data.frame(), include_dataframes = TRUE) # TRUE\n#' }\n#' @concept is_type\n#'\nis_list <- function(x, include_dataframes = FALSE){\n  is.list(x) && (!is.data.frame(x) || include_dataframes)\n}\n\n#' Check if a value is reactive\n#'\n#' This function checks if a value is reactive\n#'\n#' @param x A value to check.\n#' @return A logical scalar indicating whether `x` is a list.\n#' @examples\n#' if(interactive()){\n#' is_reactive(shiny::reactive(1)) # TRUE\n#' is_reactive(1) # FALSE\n#' }\n#'\n#' @concept is_type\n#'\nis_reactive <- function(x){\n  rlang::check_installed(\"shiny\")\n  shiny::is.reactive(x)\n}\n\nis_whole_number <- function(x){\n  return(x%%1==0)\n}\n\nis_connection <- function(x){\n  inherits(x, \"DBIConnection\")\n}\n\n# Advanced ----------------------------------------------------------------\n# assert_create_advanced functions -----------------------------------------\n# These functions are for feeding into assert_create_advanced\n# They take an object and instead of returning TRUE/FALSE, they return TRUE if assertion should pass,\n# and the error message to throw if assertion should fail\n\n\n#' Check if x is a number\n#'\n#' This function is designed for use with `assert_create_advanced`. It must return\n#' TRUE for the assertion to pass or a string representing the error message if the\n#' assertion should fail.\n#'\n#' @param x A value to be checked\n#'\n#' @return Returns invisible(TRUE) if x is a numeric value with length 1. Returns a string\n#' with an error message if x is not a numeric value or has a length other than 1.\n#'\n#' @concept advanced\nis_number_advanced <- function(x){\n  if(!is.numeric(x))\n    return(\"'{.strong {arg_name}}' is not a {.strong number}! (class is {.strong {class(arg_value)}}, not {.strong numeric})\")\n\n  if(length(x) != 1)\n    return(\"'{.strong {arg_name}}' is not a {.strong number}! (length is {.strong {length(arg_value)}}, not {.strong 1})\")\n\n  return(invisible(TRUE))\n}\n\n#' Check if x is a flag\n#'\n#' This function is designed for use with `assert_create_advanced`. It must return\n#' TRUE for the assertion to pass or a string representing the error message if the\n#' assertion should fail.\n#'\n#' @param x A value to be checked\n#'\n#' @return Returns invisible(TRUE) if x is a logical value with length 1. Returns a string\n#' with an error message if x is not a logical value or has a length other than 1.\n#'\n#'\n#' @concept advanced\nis_flag_advanced <- function(x){\n  if(!is.logical(x))\n    return(\"'{.strong {arg_name}}' is not a {.strong flag}! (class is {.strong {class(arg_value)}}, not {.strong logical})\")\n\n  if(length(x) != 1)\n    return(\"'{.strong {arg_name}}' is not a {.strong flag}! (length is {.strong {length(arg_value)}}, not {.strong 1})\")\n\n  return(invisible(TRUE))\n}\n\n#' Check if x is a string\n#'\n#' This function is designed for use with `assert_create`. It returns\n#' TRUE for the assertion to pass or a string representing the error message if the\n#' assertion should fail.\n#'\n#' @param x A value to be checked\n#'\n#' @return Returns invisible(TRUE) if x is a character value with length 1. Returns a string\n#' with an error message if x is not a character value or has a length other than 1.\n#'\n#' @concept advanced\nis_string_advanced <- function(x){\n  if(!is.character(x))\n    return(\"'{.strong {arg_name}}' is not a {.strong string}! (class is {.strong {class(arg_value)}}, not {.strong character})\")\n\n  if(length(x) != 1)\n    return(\"'{.strong {arg_name}}' is not a {.strong string}! (length is {.strong {length(arg_value)}}, not {.strong 1})\")\n\n  return(invisible(TRUE))\n}\n\n\n#' Check if x is a nonempty string\n#'\n#' This function is designed for use with `assert_create`. It returns\n#' TRUE for the assertion to pass or a string representing the error message if the\n#' assertion should fail.\n#'\n#'\n#'\n#' @param x A value to be checked\n#'\n#' @return Returns invisible(TRUE) if x is a character value with length 1 and at least 1 character in string. Returns a string\n#' with an error message if x is not a character value or has a length other than 1.\n#'\n#' @concept advanced\nis_non_empty_string_advanced <- function(x){\n  is_string_res <-  is_string_advanced(x)\n\n  if(is.character(is_string_res))\n    return(is_string_res)\n  else if(nchar(x) == 0)\n    return(\"'{.strong {arg_name}}' is an {.strong empty} string!\")\n\n  return(invisible(TRUE))\n}\n\n\n\n\n","type":"text"},{"name":"assertions/set_operations.R","content":"# Set functions -----------------------------------------------------------\n#' Check if one set is a subset of another\n#'\n#' Determines if all elements in set `x` are also present in set `y`.\n#'\n#' @param x A numeric, character, or logical vector.\n#' @param y A numeric, character, or logical vector.\n#' @return A logical value indicating whether `x` is a subset of `y`.\n#'\nis_subset <- function(x, y){\n  all(x %in% y)\n}\n\n\n#' Check if one set is a superset of another\n#'\n#' Determines if all elements in set `y` are also present in set `x`.\n#'\n#' @param x A numeric, character, or logical vector.\n#' @param y A numeric, character, or logical vector.\n#' @return A logical value indicating whether `x` is a superset of `y`.\nis_superset <- function(x, y){\n  all(y %in% x)\n}\n\n# Set Differences ---------------------------------------------------------------------\n\n#' @title Elements Exclusive to First Set\n#'\n#' @description\n#' Finds the elements that are in the first set but not in the second set.\n#'\n#' @param x A vector of elements.\n#' @param y A vector of elements.\n#'\n#' @return A vector of elements that are in the first set but not in the second set.\n#'\nsetopts_exlusive_to_first <- function(x, y){\n  setdiff(x, y)\n}\n\n#' @title Count of Elements Exclusive to First Set\n#'\n#' @description\n#' Counts the number of elements that are in the first set but not in the second set.\n#'\n#' @param x A vector of elements.\n#' @param y A vector of elements.\n#'\n#' @return A scalar representing the number of elements that are in the first set but not in the second set.\n#'\nsetopts_count_exlusive_to_first <- function(x, y){\n  length(setdiff(x, y))\n}\n\n#' @title Find Common Elements\n#'\n#' @description\n#' Find the elements that are present in both sets.\n#'\n#' @param x A vector of elements.\n#' @param y A vector of elements.\n#'\n#' @return A vector of elements that are present in both sets.\n#'\nsetopts_common_elements <- function(x, y){\n  intersect(x, y)\n}\n\n#' @title Compare Sets for Equality\n#'\n#' @description\n#' Determine if the two sets are equal.\n#'\n#' @param x A vector of elements.\n#' @param y A vector of elements.\n#'\n#' @return A logical value indicating whether the sets are equal (`TRUE`) or not (`FALSE`).\n#'\nsetopts_are_equal <- function(x, y){\n  setequal(x, y)\n}\n\n\n\n# Includes ----------------------------------------------------------------\n\n#' Check if All Values in Required are in x\n#'\n#' @description\n#' Checks if all elements of `required` are present in `x`.\n#'\n#' @param x A vector of elements.\n#' @param required A vector of elements to check for inclusion in `x`.\n#'\n#' @return A logical value indicating whether all elements of `required` are present in `x` (`TRUE`) or not (`FALSE`).\n#'\nincludes <- function(x, required){\n  is_subset(required, x)\n}\n\n#' Check if an object contains required elements\n#'\n#' This function checks that `x` includes all of the `required` elements.\n#' `x` must be the same type as `required`.\n#' Factors are treated as character vectors.\n#'\n#' @param x An object to check\n#' @param required The required elements to check for\n#' @return Returns TRUE if `x` is the same type as `required` and `x` includes all the `required` elements.\n#' Otherwise returns a string representing the appropriate error message to display\nincludes_advanced <- function(x, required){\n\n  # Special rules for factors (we treat them as characters)\n  if(is.factor(x)) {\n    x <- as.character(x)\n    if(is.numeric(required)) required <- as.character(required)\n  }\n\n  if(!is_same_type(x, required))\n    return(\"'{.strong {arg_name}}' (type: {.strong {typeof(x)}}) must be the same type as {deparse(substitute(required))} (type: {typeof(required)})\")\n  else{\n    if(!is_subset(required, x)){\n      missing <- setopts_exlusive_to_first(required, x)\n      missing <- glue::glue_collapse(missing, sep = \", \", last = \" and \")\n      return(paste0(\"'{.strong {arg_name}}' must include {.strong \",missing,\"}\", collapse = \"\"))\n    }\n  }\n  return(TRUE)\n}\n\n\n#' Check if an object does not contain prohibited elements\n#'\n#' This function checks that `x` does not include any of the `illegal` elements.\n#' `x` must be the same type as `illegal`.\n#' Factors are treated as character vectors.\n#'\n#' @param x An object to check\n#' @param illegal The prohibited elements to check for\n#' @return Returns TRUE if `x` is the same type as `illegal` and `x` does not include any of the `illegal` elements.\n#' Otherwise returns a string representing the appropriate error message to display\nexcludes_advanced <- function(x, illegal){\n\n  # Special rules for factors (we treat them as characters)\n  if(is.factor(x)) {\n    x <- as.character(x)\n    if(is.numeric(illegal)) illegal <- as.character(illegal)\n  }\n\n  if(!is_same_type(x, illegal))\n    return(\"'{.strong {arg_name}}' (type: {.strong {typeof(x)}}) must be the same type as {deparse(substitute(illegal))} (type: {typeof(illegal)})\")\n  else{\n    if(any(illegal %in% x)){\n      illegal_in_x <- setopts_common_elements(illegal, x)\n      illegal_in_x <- glue::glue_collapse(illegal_in_x, sep = \", \", last = \" and \")\n      return(paste0(\"'{.strong {arg_name}}' must exclude: {.strong \",illegal_in_x,\"}\"))\n    }\n  }\n  return(TRUE)\n}\n\n\nsets_are_equivalent <- function(x, y){\n  if(setequal(x, y))\n    return(TRUE)\n\n  extra_values <- setopts_exlusive_to_first(x, y)\n  missing_values <- setopts_exlusive_to_first(y, x)\n\n  any_extra = length(extra_values) > 0\n  any_missing = length(missing_values) > 0\n\n  failure_mode <- if(any_extra & any_missing) \"both\"\n                        else if (any_extra & !any_missing) \"extra\"\n                        else if(any_missing & !any_extra) \"missing\"\n\n  missing_plural = if(length(missing_values) > 1) \"s\" else \"\"\n  missing_plural_the = if(length(missing_values) < 2) \"a \" else \"\"\n  extra_plural = if(length(extra_values) > 1) \"s\" else \"\"\n  extra_plural_the = if(length(extra_values) < 2) \"an \" else \"\"\n\n\n  if(failure_mode == \"both\"){\n   return(paste0(\"'{arg_name}' is missing \",missing_plural_the,\"required value\",missing_plural,\": {setopts_exlusive_to_first(y, x)}, and contains \",extra_plural_the, \"unexpected value\", extra_plural,\": {setopts_exlusive_to_first(x, y)}.\"))\n  }\n  else if(failure_mode == \"extra\"){\n    return(paste0(\"'{arg_name}' contains \", extra_plural_the, \"unexpected value\",extra_plural,\": {setopts_exlusive_to_first(x, y)}.\"))\n  }\n  else if(failure_mode == \"missing\"){\n    return(paste0(\"'{arg_name}' is missing \" ,missing_plural_the, \"required value\",missing_plural,\": {setopts_exlusive_to_first(y, x)}.\"))\n  }\n}\n","type":"text"},{"name":"assertions/utils.R","content":"\n#' Common Parameter Descriptions\n#'\n#' @param call Only relevant when pooling assertions into multi-assertion helper functions. See \\link[cli]{cli_abort} for details.\n#' @param arg_name Advanced use only. Name of the argument passed (default: NULL, will automatically extract arg_name).\n#' @param msg The error message thrown if the assertion fails (string)\n#' @param ... Used to pass any arguments to assertion function\n#'\n#'\ncommon_roxygen_params <- function(call, arg_name, msg, ...){\n\n}\n\n\n# Cli formatting helpers --------------------------------------------------\n\n#' Preprocess character vectors for cli::cli_abort()\n#'\n#' The \\code{format_as_bullets} function is used for preprocessing character vectors by adding names.\n#' These names are used to denote bullet points when the character vector is passed to \\code{cli::cli_abort()}.\n#' This allows for the easy creation of bullet point lists in error messages.\n#' The bullet argument allows the user to specify the desired bullet point symbol.\n#' The default bullet point symbols are: *, >, , x, v, i, and !.\n#'\n#' @param x A list of character strings\n#' @param bullet One of '', '>', ' ', 'x', 'v', 'i', '!' (default: '')\n#' The character to use as the bullet point for each element of x.\n#'\n#' @return A character string with each element of x formatted as a bullet point\n#'\nformat_as_bullets <- function(x, bullet = c('*', '>', ' ', 'x', 'v', 'i', '!')){\n  bullet <- rlang::arg_match(bullet)\n  names(x) <- rep(bullet, times = length(x))\n  return(x)\n}\n\n\n#' Preprocess character vectors for cli package functions\n#'\n#' @param x A character vector\n#' @param inline_tag A character vector of inline tag names (e.g. \"strong\", \"emph\", \"code\", \"arg\")\n#'\n#' @return A character vector with inline tags applied to each element\n#'\n#'\nformat_inline <- function(x, inline_tag = c('strong', 'emph', 'code', 'arg')){\n  inline_tag <- rlang::arg_match(inline_tag)\n  x <- paste0('{.', inline_tag, ' ', x, '}')\n  return(x)\n}\n\nformat_escape_curly <- function(x){\n  x <- gsub(x = x, pattern = \"{\", replacement = \"{{\", fixed = TRUE)\n  x <- gsub(x = x, pattern = \"}\", replacement = \"}}\", fixed = TRUE)\n}\n\n\n# Function assertions ---------------------------------------------------------------\nfunc_arg_names <- function(func){\n  names(formals(args(func)))\n}\n\nfunc_supports_variable_arguments <- function(func){\n  arg_names <- func_arg_names(func)\n  any(grepl(x = arg_names, pattern = \"...\", fixed = TRUE))\n}\n\nfunc_args_as_pairlist <- function(func){\n  formals(args(func))\n}\n#\n# func_args_as_alist <- function(func){\n#   a= unlist(func_args_as_pairlist(func))\n# }\n\n# func_arg_remove_defaults <- function(func, n){\n#   #foo <- as.pairlist(alist(foo=)) ; names(foo) <- names(formals(f))[1]; formals(f)[1] <- foo; f\n#   formals(func)[[1]] <- substitute()\n#   return(func)\n# }\n\n\nfunc_arg_count <- function(func, dots = c(\"throw_error\", \"count_as_0\", \"count_as_1\", \"count_as_inf\")){\n\n  dots <- rlang::arg_match(dots)\n\n  param_names <- func_arg_names(func)\n  param_count <- length(param_names)\n\n  supports_varargs <-  func_supports_variable_arguments(func)\n\n  if(supports_varargs){\n    if (dots == \"throw_error\") { cli::cli_abort(\"Cannot count number of arguments if there are dots (...) present. Can explicitly set how we should deal with this problem via the dots argument\") }\n    else if (dots == \"count_as_0\") { param_count <- param_count - 1 }\n    else if (dots == \"count_as_1\") { param_count <- param_count }\n    else if (dots == \"count_as_inf\") { param_count <- Inf }\n\n  }\n\n  return(param_count)\n}\n\n\n# func_arg_has_dots <- function(func){\n#   any(func_arg_names(func) == \"...\")\n# }\n#\n# func_arg_default_status <- function(func){\n#   args <- func_args_as_pairlist(func)\n#   lgl <- unlist(args) == substitute()\n#   return(lgl)\n# }\n\nrequired_args_are_missing <- function(fun = sys.function(-1), ncall = 3) {\n  f_args <- formals(fun)\n  f_args <- f_args[vapply(f_args, is.symbol, FUN.VALUE = TRUE)]\n  f_args <- names(f_args)\n  f_args <- setdiff(f_args, \"...\")\n  test <- vapply(f_args,\n                 function(x) methods::missingArg(as.name(x), envir = parent.frame(ncall), eval = TRUE),\n                 FUN.VALUE = TRUE)\n  return(any(test))\n}\n","type":"text"},{"name":"gg1d/data.R","content":"#' Lazy Birdwatcher Dataset\n#'\n#' A simulated dataset describing the number of magpies observed by two birdwatchers.\n#'\n#' @format ## `lazy_birdwatcher`\n#' A data frame with 45 rows and 3 columns:\n#'\n#' \\describe{\n#'   \\item{Magpies}{Number of magpies observed}\n#'   \\item{Day}{Was the day of observation a weekday or a weekend?}\n#'   \\item{Birdwatcher}{Name of the birdwatcher}\n#' }\n\"lazy_birdwatcher\"\n","type":"text"},{"name":"gg1d/gg1d.R","content":"utils::globalVariables(\".data\")\n\n#' AutoPlot an entire data.frame\n#'\n#' Visualize all columns in a data frame with gg1d's vertically aligned plots\n#' and automatic plot selection based on variable type.\n#' Plots are fully interactive, and custom tooltips can be added.\n#'\n#' @param data data.frame to autoplot (data.frame)\n#' @param maxlevels for categorical variables, what is the maximum number of distinct values to allow (too many will make it hard to find a palette that suits). (number)\n#' @param verbose Numeric value indicating the verbosity level:\n#'   \\itemize{\n#'     \\item \\strong{2}: Highly verbose, all messages.\n#'     \\item \\strong{1}: Key messages only.\n#'     \\item \\strong{0}: Silent, no messages.\n#'   }\n#' @param col_id name of column to use as an identifier. If null, artificial IDs will be created based on row-number.\n#' @param col_sort name of columns to sort on. To do a hierarchical sort, supply a vector of column names in the order they should be sorted (character).\n#' @param order_matches_sort should the column plots be stacked top-to-bottom in the order they appear in \\code{col_sort} (flag)\n#' @param drop_unused_id_levels if col_id is a factor with unused levels, should these be dropped or included in visualisation\n#' @param interactive produce interactive ggiraph visualiastion (flag)\n#' @param return a string describing what this function should return. Options include:\n#'   \\itemize{\n#'     \\item \\strong{plot}: Return the gg1d visualisation (default)\n#'     \\item \\strong{colum_info}: Return a data.frame describing the columns the dataset.\n#'     \\item \\strong{data}: Return the processed dataset used for plotting.\n#'   }\n#' @param palettes A list of named vectors. List names correspond to \\strong{data} column names (categorical only). Vector names to levels of columns. Vector values are colours, the vector names are used to map values in data to a colour.\n#' @param sort_type controls how categorical variables are sorted.\n#' Numerical variables are always sorted in numerical order irrespective of the value given here.\n#' Options are `alphabetical` or `frequency`\n#' @param desc sort in descending order (flag)\n#' @param limit_plots throw an error when there are > \\code{max_plottable_cols} in dataset (flag)\n#' @param max_plottable_cols maximum number of columns that can be plotted (default: 15) (number)\n#' @param cols_to_plot names of columns in \\strong{data} that should be plotted. By default plots all valid columns (character)\n#' @param tooltip_column_suffix the suffix added to a column name that indicates column should be used as a tooltip (string)\n#' @param ignore_column_regex a regex string that, if matches a column name,  will cause that  column to be exclude from plotting (string)  (default: \"_ignore$\")\n#' @param convert_binary_numeric_to_factor  If a numeric column conatins only values 0, 1, & NA, then automatically convert to a factor.\n#' @param options a list of additional visual parameters created by calling [gg1d_options()]. See \\code{\\link{gg1d_options}} for details.\n#'\n#' @return ggiraph interactive visualisation\n#'\n#' @examples\n#' path_gg1d <- system.file(\"example.csv\", package = \"gg1d\")\n#' df <- read.csv(path_gg1d, header = TRUE, na.strings = \"\")\n#'\n#' # Create Basic Plot\n#' gg1d(df, col_id = \"ID\", col_sort = \"Glasses\")\n#'\n#' # Configure plot gg1d_options()\n#' gg1d(\n#'   lazy_birdwatcher,\n#'   col_sort = \"Magpies\",\n#'   palettes = list(\n#'     Birdwatcher = c(Robert = \"#E69F00\", Catherine = \"#999999\"),\n#'     Day = c(Weekday = \"#999999\", Weekend = \"#009E73\")\n#'   ),\n#'   options = gg1d_options(\n#'     show_legend = TRUE,\n#'     fontsize_barplot_y_numbers = 12,\n#'     legend_text_size = 16,\n#'     legend_key_size = 1,\n#'     legend_nrow = 1,\n#'   )\n#' )\n#'\n#' @importFrom ggplot2 ggplot aes geom_col geom_tile theme %+replace% element_blank element_text element_line\n#' @export\n#'\ngg1d <- function(\n    data, col_id = NULL, col_sort = NULL,\n    order_matches_sort = TRUE,\n    maxlevels = 6,\n    verbose = 2,\n    drop_unused_id_levels = FALSE,\n    interactive = TRUE,\n    return = c(\"plot\", \"column_info\", \"data\"),\n    palettes = NULL,\n    sort_type = c(\"frequency\", \"alphabetical\"),\n    desc = TRUE,\n    limit_plots = TRUE,\n    max_plottable_cols = 15,\n    cols_to_plot = NULL,\n    tooltip_column_suffix = \"_tooltip\",\n    ignore_column_regex = \"_ignore$\",\n    convert_binary_numeric_to_factor = TRUE,\n    options = gg1d_options(show_legend = !interactive)) {\n  # Data validation\n  assert_dataframe(data)\n  assert_number(maxlevels)\n  assert_flag(drop_unused_id_levels)\n  assert_flag(interactive)\n  assert_flag(limit_plots)\n  assert_flag(desc)\n  assert_string(tooltip_column_suffix)\n  assert_string(ignore_column_regex)\n  assert_class(options, \"gg1d_options\", msg = \"The options argument must be created using {.code gg1d_options()}\")\n  assert_number(max_plottable_cols)\n  assert_greater_than(max_plottable_cols, 0)\n  assert_flag(order_matches_sort)\n  assert_flag(convert_binary_numeric_to_factor)\n\n  # Conditional checks for non-gg1d_options parameters\n  if (!is.null(cols_to_plot)) assert_names_include(data, names = cols_to_plot)\n  if (!is.null(palettes)) assert_list(palettes)\n  if (!all(colnames(data) %in% names(palettes))) assert_greater_than_or_equal_to(length(options$colours_default), minimum = maxlevels)\n\n  # Argument Matching\n  sort_type <- rlang::arg_match(sort_type)\n  return <- rlang::arg_match(return)\n\n\n  # Formatting --------------------------------------------------------------\n  cli::cli_div(theme = list(span.warn = list(color = \"yellow\", \"font-weight\" = \"bold\")))\n  cli::cli_div(theme = list(span.success = list(color = \"darkgreen\", \"font-weight\" = \"bold\")))\n\n  # Add a title message\n  if (verbose >= 1) cli::cli_h1(options$cli_header)\n\n  # Preprocessing -----------------------------------------------------------\n  # Add col_id column if it user hasn't supplied one\n  if (is.null(col_id)) {\n    col_id_manually_specified <- FALSE\n    col_id <- \"DefaultID\"\n    data[[col_id]] <- seq_len(nrow(data))\n  } else {\n    col_id_manually_specified <- TRUE\n    assert_string(col_id)\n    assert_names_include(data, names = col_id, msg = \"Column {.code {col_id}} does not exist in your dataset. Please set the {.arg col_id} argument to a valid column name.\")\n    assert_no_duplicates(data[[col_id]])\n  }\n\n  # Sort Order -------------------------------------------------------------------\n  # convert ID col to factor if not already\n  if (!is.factor(data[[col_id]])) {\n    data[[col_id]] <- as.factor(data[[col_id]])\n  }\n\n  if (verbose) cli::cli_h3(\"Sorting\")\n\n  if (is.null(col_sort)) {\n    if (verbose >= 1) cli::cli_alert_info(\"Sorting X axis by: Order of appearance\")\n  } else {\n    assert_character_vector(col_sort)\n    assert_length_greater_than(col_sort, length = 0)\n    assert_names_include(data, names = col_sort, msg = \"Column {.code {col_sort}} does not exist in your dataset. Please set the {.arg col_sort} argument to a valid column name.\")\n\n    if (verbose >= 1) {\n      cli::cli_bullets(c(\n        \"*\" = \"Sorting X axis by: {.strong {col_sort}}\",\n        \"*\" = \"Order type: {.strong {sort_type}}\",\n        \"*\" = \"Sort order: {.strong {ifelse(desc, 'descending', 'ascending')}}\"\n      ))\n    }\n\n    # Heirarchical Sort by specified columns\n    ranks <- lapply(col_sort, function(column_to_sort_by){\n      rank::smartrank(data[[column_to_sort_by]], sort_by = sort_type, desc = desc, verbose = FALSE)\n    })\n\n    order_hierarchical <- do.call(order, ranks)\n    data <- data[order_hierarchical,]\n    data[[col_id]] <- fct_inorder(data[[col_id]])\n\n    # Order columns based\n    if(order_matches_sort) {\n      data <- data[,c(col_sort, setdiff(colnames(data), col_sort))]\n    }\n  }\n\n  # Autoconvert numerics with only values 0, 1, NA to logicals\n  if(convert_binary_numeric_to_factor){\n    data <- convert_numerics_with_only_values_0_1_and_NA_to_logicals(data, exclude = col_id)\n  }\n\n  # Identify Plottable Columns  ------------------------------------------------------------\n  df_col_info <- column_info_table(\n    data,\n    maxlevels = maxlevels,\n    col_id = col_id,\n    cols_to_plot = cols_to_plot,\n    tooltip_column_suffix = tooltip_column_suffix,\n    palettes = palettes,\n    colours_default = options$colours_default,\n    colours_default_logical = options$colours_default_logical,\n    ignore_column_regex = ignore_column_regex,\n    verbose = verbose\n  )\n\n  # Debug Options: return column info or processed dataframe\n  if (return == \"column_info\")\n    return(df_col_info)\n  else if(return == \"data\")\n   return(data)\n  else if(return != \"plot\")\n    stop(\"No implementation has been written for debug = \", debug, \". Please create a github issue with this error message: https://github.com/selkamand/gg1d/issues/new\")\n\n  # Plot --------------------------------------------------------------------\n  if (verbose) cli::cli_h3(\"Generating Plot\")\n  plottable_cols <- sum(df_col_info$plottable == TRUE)\n\n  if (verbose >= 1) {\n    cli::cli_alert_info(\"Found {.strong {plottable_cols}} plottable columns in {.strong data}\")\n  }\n\n  # Make sure theres not too many plottable cols\n  if (limit_plots && plottable_cols > max_plottable_cols) {\n    cli::cli_abort(\"Autoplotting > {max_plottable_cols} fields by `gg1d` is not recommended (visualisation ends up very squished). If you're certain you want to proceed, set limit_plots = `FALSE`. Alternatively, use `cols_to_plot` to specify <={max_plottable_cols} columns within your dataset.\")\n  }\n\n  # Make sure theres at least 1 plottable column\n  if (plottable_cols == 0) {\n    cli::cli_abort(\"No plottable columns found\")\n  }\n\n  gglist <- lapply(\n    X = seq_len(nrow(df_col_info)),\n    function(i) {\n      colname <- df_col_info[[\"colnames\"]][i]\n      coltype <- df_col_info[[\"coltype\"]][i]\n      coltooltip <- df_col_info[[\"coltooltip\"]][i]\n      ndistinct <- df_col_info[[\"ndistinct\"]][i]\n      plottable <- df_col_info[[\"plottable\"]][i]\n      palette <- unlist(df_col_info[[\"palette\"]][i])\n\n\n      # Don't plot if not plottable\n      if (!plottable) {\n        # If column is the sorting Identifier - don't info about it\n        if (colname == col_id) {\n          return(NULL)\n        }\n        if (verbose >= 2) cli::cli_alert_warning(\"{.warn Skipping} column {.strong {colname}}\")\n        return(NULL)\n      } else {\n        if (verbose >= 2) cli::cli_alert_success(\"{.success Plotting} column {.strong {colname}}\")\n      }\n\n\n      ## Create Interactive Geoms Aesthetics ---------------------------------------------\n      if (!is.na(coltooltip)) {\n        # If user specifies a custom tooltip using _tooltip suffix column\n        # we just use that as the tooltip\n        data[[coltooltip]] <- ifelse(is.na(data[[coltooltip]]), \"\", data[[coltooltip]])\n        tooltip_text <- data[[coltooltip]]\n      } else {\n        # Construct the default tooltip\n        tooltip_text <- paste0(\n          tag_bold(colname), \": \", data[[colname]],\n\n          # Only describe ID column if col_id was manually specified\n          if (col_id_manually_specified) {\n            paste0(\n              \"<br/>\",\n              tag_bold(col_id), \": \", data[[col_id]]\n            )\n          } else {\n            \"\"\n          }\n        )\n      }\n      aes_interactive <- aes(\n        data_id = .data[[col_id]],\n        tooltip = tooltip_text\n      )\n\n      # Draw the actual plot\n\n      ## Categorical -------------------------------------------------------------\n      if (coltype == \"categorical\") {\n        gg <- ggplot(\n          data,\n          aes(\n            x = .data[[col_id]],\n            y = if (options$beautify_text) beautify(colname) else colname,\n            fill = .data[[colname]]\n          )\n        ) +\n          ggiraph::geom_tile_interactive(mapping = aes_interactive, width = options$width, na.rm = TRUE) +\n          {\n            if (options$show_na_marker_categorical) {\n              ggplot2::geom_text(\n                data = function(x) {\n                  x[is.na(x[[colname]]), , drop = FALSE]\n                }, # only add text where value is NA\n                aes(label = options$na_marker), size = options$na_marker_size, na.rm = TRUE, vjust = 0.5, color = options$na_marker_colour,\n              )\n            }\n          } +\n          ggplot2::scale_x_discrete(drop = drop_unused_id_levels) +\n          ggplot2::guides(fill = ggplot2::guide_legend(\n            title.position = options$legend_title_position,\n            title = if (options$beautify_text) beautify(colname) else colname,\n            nrow = min(ndistinct, options$legend_nrow),\n            ncol = min(ndistinct, options$legend_ncol),\n          )) +\n          theme_categorical(\n            show_legend_titles = options$show_legend_titles,\n            show_legend = options$show_legend,\n            legend_position = options$legend_position,\n            legend_title_size = options$legend_title_size,\n            legend_text_size = options$legend_text_size,\n            legend_key_size = options$legend_key_size,\n            vertical_spacing = options$vertical_spacing,\n            fontsize_y_title = options$fontsize_y_title\n          ) +\n          ggplot2::ylab(if (options$beautify_text) beautify(colname) else colname) +\n          ggplot2::scale_fill_manual(values = palette, na.value = options$colours_missing) +\n          ggplot2::scale_y_discrete(position = options$y_axis_position)\n      }\n      # Numeric Bar -------------------------------------------------------------------------\n      else if (coltype == \"numeric\" && options$numeric_plot_type == \"bar\") {\n        breaks <- sensible_3_breaks(data[[colname]], digits = options$max_digits_barplot_y_numbers)\n        labels <- sensible_3_labels(\n          data[[colname]],\n          axis_label = if (options$beautify_text) beautify(colname) else colname,\n          fontsize_y_title = options$fontsize_y_title,\n          digits = options$max_digits_barplot_y_numbers\n        )\n\n        gg <- ggplot2::ggplot(data, aes(x = .data[[col_id]], y = .data[[colname]])) +\n          ggiraph::geom_col_interactive(mapping = aes_interactive, width = options$width, na.rm = TRUE) +\n          ggplot2::geom_text(\n            data = function(x) {\n              x[is.na(x[[colname]]), , drop = FALSE]\n            }, # only add text where value is NA\n            aes(label = options$na_marker, y = 0), size = options$na_marker_size, na.rm = TRUE, vjust = 0, color = options$na_marker_colour\n          ) +\n          ggplot2::scale_x_discrete(drop = drop_unused_id_levels) +\n          # ggplot2::geom_hline(yintercept = breaks[c(1, 3)]) +\n          ggplot2::scale_y_continuous(\n            breaks = breaks,\n            labels = labels,\n            position = options$y_axis_position,\n            limits = c(breaks[3], breaks[1]),\n            expand = c(0, 0)\n          ) +\n          theme_numeric_bar(vertical_spacing = options$vertical_spacing, fontsize_barplot_y_numbers = options$fontsize_barplot_y_numbers)\n      }\n      # Numeric Heatmap -------------------------------------------------------------------------\n      else if (coltype == \"numeric\" && options$numeric_plot_type == \"heatmap\") {\n        colname_formatted <- if (options$beautify_text) beautify(colname) else colname\n        gg <- ggplot2::ggplot(data, aes(\n          x = .data[[col_id]],\n          y = colname,\n          fill = .data[[colname]]\n        )) +\n          ggiraph::geom_tile_interactive(mapping = aes_interactive, width = options$width, na.rm = TRUE) +\n          ggplot2::scale_x_discrete(drop = drop_unused_id_levels) +\n          ggplot2::scale_y_discrete(position = options$y_axis_position) +\n          {\n            if (options$show_na_marker_heatmap) {\n              ggplot2::geom_text(\n                data = function(x) {\n                  x[is.na(x[[colname]]), , drop = FALSE]\n                }, # only add text where value is NA\n                aes(label = options$na_marker), size = options$na_marker_size, na.rm = TRUE, vjust = 0.5\n              )\n            }\n          } +\n          {\n            if (options$show_values_heatmap) {\n              ggplot2::geom_text(\n                aes(label = .data[[colname]]),\n                size = options$fontsize_values_heatmap, color = options$colours_values_heatmap, na.rm = TRUE, vjust = 0.5\n              )\n            }\n          } +\n          ggplot2::ylab(colname_formatted) +\n          theme_numeric_heatmap(\n            show_legend_titles = options$show_legend_titles,\n            show_legend = options$show_legend,\n            legend_position = options$legend_position,\n            legend_title_size = options$legend_title_size,\n            legend_text_size = options$legend_text_size,\n            legend_key_size = options$legend_key_size,\n            vertical_spacing = options$vertical_spacing,\n            fontsize_y_title = options$fontsize_y_title\n          ) +\n          ggplot2::scale_fill_gradient(\n            low = options$colours_heatmap_low,\n            high = options$colours_heatmap_high,\n            na.value = options$colours_missing,\n            trans = options$transform_heatmap,\n            guide = ggplot2::guide_colorbar(\n              direction = if (options$legend_orientation_heatmap == \"horizontal\") \"horizontal\" else \"vertical\",\n              title.position = \"top\",\n              title = if (!options$show_legend_title) NULL else colname_formatted,\n              title.hjust = 0\n            )\n          )\n      } else {\n        cli::cli_abort(\"Unsure how to plot coltype: {coltype}\")\n      }\n      return(gg)\n    }\n  )\n  names(gglist) <- df_col_info[[\"colnames\"]]\n\n  # Remove null columns\n  gglist <- gglist[!vapply(gglist, is.null, logical(1))]\n\n  # Align only axes (not labels)\n  gglist <- lapply(gglist, FUN = function(p) {\n    patchwork::free(p, type = \"label\")\n  })\n\n  # Get relative heights for plots (make numeric variables taller)\n  relheights <- ifelse(\n    df_col_info$coltype[df_col_info$plottable] == \"numeric\",\n    yes = options$relative_height_numeric,\n    no = 1\n  )\n\n  # Align Plots Vertically --------------------------------------------------\n  if (verbose >= 2) cli::cli_alert_info(\"Stacking plots vertically\")\n\n  ggpatch <- patchwork::wrap_plots(\n    gglist,\n    ncol = 1,\n    heights = relheights,\n    guides = if (options$legend_position %in% c(\"bottom\", \"top\")) \"collect\" else NULL\n  )\n\n  if(options$legend_position %in% c(\"bottom\", \"top\"))\n    ggpatch <- ggpatch & theme(legend.position = options$legend_position)\n\n  # Interactivity -----------------------------------------------------------\n  if (interactive) {\n    if (verbose >= 2) cli::cli_alert_info(\"Making plot interactive since `interactive = TRUE`\")\n    ggpatch <- ggiraph::girafe(\n      ggobj = ggpatch,\n      width_svg = options$interactive_svg_width,\n      height_svg = options$interactive_svg_height,\n      options = list(\n        opts_hover = ggiraph::opts_hover(css = \"stroke:black;cursor:pointer;r:5px;\")\n      )\n    )\n  } else {\n    if (verbose >= 2) cli::cli_alert_info(\"Rendering static plot. For interactive version set `interactive = TRUE`\")\n  }\n\n  # Return -----------------------------------------------------------\n  return(ggpatch)\n}\n\n\n#' Parse a tibble and ensure it meets standards\n#'\n#' @inheritParams gg1d\n#' @inheritParams gg1d_options\n#'\n#' @return tibble with the following columns:\n#' 1) colnames\n#' 2) coltype (categorical/numeric/tooltip/invalid)\n#' 3) ndistinct (number of distinct values)\n#' 4) plottable (should this column be plotted)\n#' 4) tooltip_col (the name of the column to use as the tooltip) or NA if no obvious tooltip column found\n#'\n#'\ncolumn_info_table <- function(data, maxlevels = 6, col_id = NULL, cols_to_plot, tooltip_column_suffix = \"_tooltip\", ignore_column_regex = \"_ignore$\", palettes, colours_default, colours_default_logical, verbose) {\n  # Assertions\n  assert_string(col_id)\n  assert_names_include(data, col_id)\n\n  # Create Column Info Data\n  df_column_info <- data.frame(\n    colnames = colnames(data),\n    coltype = coltypes(data, col_id),\n    coltooltip = coltooltip(data, tooltip_column_suffix),\n    ndistinct = colvalues(data)\n  )\n\n  # Warn if unknown file type in table\n  if (c(\"invalid\") %in% df_column_info[[\"coltype\"]]) cli::cli_warn('The following columns will not be plotted due to invalid column types: {df_column_info$colnames[df_column_info$coltype==\"invalid\"]}')\n\n  # Mark columns as not plottable if\n  # 1) they are a categorical variable with more than `maxlevels` distinct values\n  # 2) Their coltype is 'invalid', 'id', or 'tooltip'\n  # 3) The`cols_to_plot` variable is suppplied and column names are NOT in the list of cols_to_plot\n  # 4) Their colnames match the _ignore suffix\n  lgl_too_many_levels <- df_column_info$coltype == \"categorical\" & df_column_info$ndistinct > maxlevels\n  df_column_info[[\"plottable\"]] <-\n    !lgl_too_many_levels & !df_column_info$coltype %in% c(\"invalid\", \"id\", \"tooltip\") &\n      (is.null(cols_to_plot) | df_column_info$colnames %in% c(cols_to_plot)) &\n      (!grepl(x = df_column_info$colnames, pattern = ignore_column_regex))\n\n\n  if (sum(lgl_too_many_levels) > 0) {\n    char_cols_with_too_many_levels <- df_column_info$colnames[lgl_too_many_levels]\n    # Only comment about those columns the user wants to plot\n    if (!is.null(cols_to_plot)) char_cols_with_too_many_levels <- char_cols_with_too_many_levels[char_cols_with_too_many_levels %in% cols_to_plot]\n    char_cols_with_too_many_levels_formatted <- paste0(char_cols_with_too_many_levels, \" (\", df_column_info$ndistinct[lgl_too_many_levels], \")\")\n    if (verbose & length(char_cols_with_too_many_levels > 0)) cli::cli_alert_warning(\"{.strong Categorical columns} must have {.strong <= {maxlevels} unique values} to be visualised. Columns with too many unique values: {.strong {char_cols_with_too_many_levels_formatted}}\")\n  }\n\n  # Add palette colours\n  df_column_info$palette <- choose_colours(\n    data,\n    palettes = palettes,\n    plottable = df_column_info$plottable,\n    ndistinct = df_column_info$ndistinct,\n    coltype = df_column_info$coltype,\n    colours_default = colours_default,\n    colours_default_logical = colours_default_logical\n  )\n\n  # Return table describing\n  return(df_column_info)\n}\n\n\ncoltooltip <- function(data, tooltip_column_suffix) {\n  vapply(\n    colnames(data),\n    function(name) {\n      colnames(data)[match(paste0(name, tooltip_column_suffix), colnames(data))]\n    },\n    character(1)\n  )\n}\n\ncoltypes <- function(data, col_id) {\n  # First Pass of coltypes\n  char_coltypes <- vapply(data, FUN = function(vec) {\n    if (is.character(vec) | is.factor(vec) | is.logical(vec)) {\n      return(\"categorical\")\n    } else if (is.numeric(vec)) {\n      return(\"numeric\")\n    } else {\n      return(\"invalid\")\n    }\n  }, FUN.VALUE = character(1))\n\n  # Overwrite coltype to tooltip if `_tooltip` suffix is found\n  char_colnames <- colnames(data)\n  tooltip_suffix <- \"_tooltip\"\n  has_tooltip_in_name <- grepl(x = char_colnames, pattern = tooltip_suffix, ignore.case = TRUE)\n  without_tooltip_has_matched_name <- gsub(x = char_colnames, pattern = tooltip_suffix, replacement = \"\") %in% char_colnames\n  is_tooltip_col <- has_tooltip_in_name & without_tooltip_has_matched_name\n\n  char_coltypes <- ifelse(is_tooltip_col, yes = \"tooltip\", no = char_coltypes)\n\n  # Overwrite coltype to 'id' if colname == col_id\n  char_coltypes <- ifelse(char_colnames == col_id, yes = \"id\", no = char_coltypes)\n\n  return(char_coltypes)\n}\n\ncolvalues <- function(data) {\n  vapply(data, FUN = function(vec) {\n    length(stats::na.omit(unique(vec)))\n  }, FUN.VALUE = numeric(1))\n}\n\nchoose_colours <- function(data, palettes, plottable, ndistinct, coltype, colours_default, colours_default_logical) {\n  assert_character(colours_default)\n\n  colors <- lapply(seq_len(ncol(data)), FUN = function(i) {\n    colname <- colnames(data)[[i]]\n    is_plottable <- plottable[[i]]\n    is_lgl <- is.logical(data[[colname]])\n\n    if (!is_plottable | coltype[i] != \"categorical\") {\n      return(NULL)\n    } else if (colname %in% names(palettes)) {\n      colors <- unlist(palettes[[colname]])\n      assert_names_include(colors, names = stats::na.omit(unique(data[[colname]])))\n      return(palettes[[colname]])\n    } else if (is_lgl) {\n      colors <- colours_default_logical\n    } else {\n      assert(length(colours_default) >= ndistinct[i], msg = \"Too many unique values in column to assign each a colour using the default palette. Either change the default palette to one that supports colours, reduce the number of levels in this column, or exclude it from the plotting using `cols_to_plot` argument OR maxlevels\")\n      colors <- colours_default\n    }\n  })\n\n  return(colors)\n}\n\n\n\n\n\ntheme_categorical <- function(fontsize_y_title = 12, show_legend = TRUE, show_legend_titles = FALSE, legend_position = \"right\", legend_title_size = NULL, legend_text_size = NULL, legend_key_size = 0.3, vertical_spacing = 0) {\n  ggplot2::theme_minimal() %+replace%\n\n    ggplot2::theme(\n      panel.grid = element_blank(),\n      axis.text.y.left = element_blank(),\n      axis.text.y.right = element_blank(),\n      axis.text.x = element_blank(),\n      axis.title.x = element_blank(),\n      axis.title.y = element_text(size = fontsize_y_title, angle = 0),\n      legend.title = if (show_legend_titles) element_text(size = legend_title_size, face = \"bold\", hjust = 0) else element_blank(),\n      legend.justification = c(0, 0.5),\n      legend.margin = ggplot2::margin(0, 0, 0, 0),\n      legend.location = \"panel\",\n      legend.text = element_text(size = legend_text_size, vjust = 0.5),\n      legend.position = if (show_legend) legend_position else \"none\",\n      strip.placement = \"outside\",\n      # plot.background = ggplot2::element_rect(color = \"red\"),\n      # panel.background = ggplot2::element_rect(color = \"black\"),\n      # legend.box.background = ggplot2::element_rect(color = \"green\"),\n      # legend.key = ggplot2::element_rect(colour = \"red\"),\n      legend.key.size = ggplot2::unit(legend_key_size, \"lines\"),\n      legend.box.margin = ggplot2::margin(0, 0, 0, 0),\n      legend.key.spacing.y = ggplot2::unit(2, \"pt\"),\n      plot.margin = ggplot2::margin(t = 0, r = 0, b = vertical_spacing, l = 0, unit = \"pt\"),\n    )\n}\n\ntheme_numeric_bar <- function(vertical_spacing = 0, fontsize_barplot_y_numbers = 8) {\n  ggplot2::theme_minimal() %+replace%\n\n    theme(\n      panel.grid = element_blank(),\n      axis.title.y.right = element_blank(),\n      axis.title.y = element_blank(),\n      axis.text.x = element_blank(),\n      axis.title.x = element_blank(),\n      axis.line.y = element_line(linewidth = 0.3),\n      axis.line.x = element_blank(),\n      axis.text.y.left = ggtext::element_markdown(size = fontsize_barplot_y_numbers, colour = \"black\"),\n      axis.text.y.right = ggtext::element_markdown(size = fontsize_barplot_y_numbers, hjust = 0),\n      axis.ticks.y = element_blank(),\n      strip.placement = \"outside\",\n      plot.margin = ggplot2::margin(t = 5, r = 0, b = vertical_spacing + 5, l = 0, unit = \"pt\")\n    )\n}\n\ntheme_numeric_heatmap <- function(fontsize_y_title = 12, show_legend = TRUE, legend_position = \"right\", show_legend_titles = FALSE, legend_title_size = NULL, legend_text_size = NULL, legend_key_size = 0.3, vertical_spacing = 0) {\n  ggplot2::theme_minimal() %+replace%\n    theme(\n      panel.grid = element_blank(),\n      axis.text.y = element_blank(),\n      axis.title.y = element_text(size = fontsize_y_title, angle = 0, colour = \"black\"),\n      axis.text.x = element_blank(),\n      axis.title.x = element_blank(),\n      legend.title = if (show_legend_titles) element_text(size = legend_title_size, face = \"bold\", hjust = 0) else element_blank(),\n      legend.justification = c(0, 0.5),\n      legend.margin = ggplot2::margin(0, 0, 0, 0),\n      legend.text = element_text(size = legend_text_size),\n      legend.position = if (show_legend) legend_position else \"none\",\n      strip.placement = \"outside\",\n      plot.margin = ggplot2::margin(t = 0, r = 0, b = vertical_spacing, l = 0, unit = \"pt\")\n    )\n}\n\n\ntag_bold <- function(x) {\n  paste0(\"<b>\", x, \"<\/b>\", collapse = \"\")\n}\n\n#' GGplot breaks\n#'\n#' Find sensible values to add 2 breaks at for a ggplot2 axis\n#'\n#' @param vector vector fed into ggplot axis you want to define sensible breaks for\n#'\n#' @return vector of length 2. first element descripts upper break position, lower describes lower break\n#'\nsensible_2_breaks <- function(vector) {\n  upper <- max(vector, na.rm = TRUE)\n  lower <- min(0, min(vector, na.rm = TRUE), na.rm = TRUE)\n  c(upper, lower)\n}\n\nsensible_3_breaks <- function(vector, digits = 3) {\n  upper <- max(vector, na.rm = TRUE)\n  lower <- min(0, min(vector, na.rm = TRUE), na.rm = TRUE)\n\n  # Round\n  if (!is.null(digits)) upper <- round_up(upper, digits)\n  if (!is.null(digits)) lower <- round_down(lower, digits)\n\n  middle <- mean(c(upper, lower))\n\n  breaks <- c(upper, middle, lower)\n\n  if (upper == lower) {\n    return(lower)\n  }\n\n  return(breaks)\n}\n\nsensible_3_labels <- function(vector, axis_label, fontsize_y_title = 14, digits = 3) {\n  upper <- max(vector, na.rm = TRUE)\n  lower <- min(0, min(vector, na.rm = TRUE), na.rm = TRUE)\n\n\n  # Round\n  if (!is.null(digits)) upper <- round_up(upper, digits)\n  if (!is.null(digits)) lower <- round_down(lower, digits)\n\n  axis_label <- paste0(\"<span style = 'font-size: \", fontsize_y_title, \"pt'>\", axis_label, \"<\/span>\")\n\n  if (lower == upper) {\n    return(axis_label)\n  }\n\n  as.character(c(upper, axis_label, lower))\n}\n\n\n#' Make strings prettier for printing\n#'\n#' Takes an input string and 'beautify' by converting underscores to spaces and\n#'\n#' @param string input string\n#' @param autodetect_units automatically detect units (e.g. mm, kg, etc) and wrap in brackets.\n#'\n#' @return string\n#'\nbeautify <- function(string, autodetect_units = TRUE) {\n  # underscores to spaces\n  string <- gsub(x = string, pattern = \"_\", replacement = \" \")\n\n  # dots to spaces\n  string <- gsub(x = string, pattern = \".\", replacement = \" \", fixed = TRUE)\n\n  # camelCase to camel Case\n  string <- gsub(x = string, pattern = \"([a-z])([A-Z])\", replacement = \"\\\\1 \\\\2\")\n\n  # Autodetect units (and move to brackets)\n  if (autodetect_units) {\n    string <- sub(\"\\\\bm\\\\b\", \"(m)\", string)\n    string <- sub(\"\\\\bmm\\\\b\", \"(mm)\", string)\n    string <- sub(\"\\\\cm\\\\b\", \"(cm)\", string)\n    string <- sub(\"\\\\km\\\\b\", \"(km)\", string)\n    string <- sub(\"\\\\bg\\\\b\", \"(g)\", string)\n    string <- sub(\"\\\\bkg\\\\b\", \"(kg)\", string)\n    string <- sub(\"\\\\bmg\\\\b\", \"(mm)\", string)\n    string <- sub(\"\\\\boz\\\\b\", \"(oz)\", string)\n    string <- sub(\"\\\\blb\\\\b\", \"(lb)\", string)\n    string <- sub(\"\\\\bin\\\\b\", \"(in)\", string)\n    string <- sub(\"\\\\bft\\\\b\", \"(ft)\", string)\n    string <- sub(\"\\\\byd\\\\b\", \"(yd)\", string)\n    string <- sub(\"\\\\bmi\\\\b\", \"(mi)\", string)\n  }\n\n\n  # Capitalise Each Word\n  string <- gsub(x = string, pattern = \"^([a-z])\", perl = TRUE, replacement = (\"\\\\U\\\\1\"))\n  string <- gsub(x = string, pattern = \" ([a-z])\", perl = TRUE, replacement = (\" \\\\U\\\\1\"))\n\n  return(string)\n}\n\nround_up <- function(x, digits) {\n  multiplier <- 10^digits\n  ceiling(x * multiplier) / multiplier\n}\n\nround_down <- function(x, digits) {\n  multiplier <- 10^digits\n  floor(x * multiplier) / multiplier\n}\n\nfct_inorder <- function(x){\n  factor(x, levels = unique(x))\n}\n\n\n# Autoconvert pseudo-logical to a factor\nnumeric_only_includes_zero_one_and_na <- function(vec){\n  is.numeric(vec) & all(unique(vec) %in% c(0, 1, NA))\n}\n\nconvert_numerics_with_only_values_0_1_and_NA_to_logicals <- function(data, exclude = NULL) {\n  col_is_convertable <- vapply(data, numeric_only_includes_zero_one_and_na, FUN.VALUE = logical(1))\n\n  if(!is.null(exclude))\n    col_is_convertable <- col_is_convertable & (colnames(data) != exclude)\n\n  data[, col_is_convertable] <- lapply(data[, col_is_convertable, drop = FALSE], as_binary_factor)\n  return(data)\n}\n\nas_binary_factor <- function(vec){\n  vec <- as.factor(vec)\n  levels(vec) <- c(0, 1, NA)\n  return(vec)\n}\n","type":"text"},{"name":"gg1d/gg1d_options.R","content":"#' Visual Parameters for gg1d Plots\n#'\n#' Configures aesthetic and layout settings for plots generated by `gg1d`.\n#'\n#' @param show_legend Display the legend on the plot (flag).\n#' @param show_legend_titles Display titles for legends (flag).\n#' @param legend_position Position of the legend (\"right\", \"left\", \"bottom\", \"top\").\n#' @param legend_title_position Position of the legend title (\"top\", \"bottom\", \"left\", \"right\").\n#' @param legend_nrow Number of rows in the legend (number).\n#' @param legend_ncol Number of columns in the legend. If set, `legend_nrow` should be `NULL` (number).\n#' @param legend_title_size Size of the legend title text (number).\n#' @param legend_text_size Size of the text within the legend (number).\n#' @param legend_key_size Size of the legend key symbols (number).\n#' @param beautify_text Beautify y-axis text and legend titles by capitalizing words and adding spaces (flag).\n#' @param vertical_spacing Space between each data row in points (number).\n#' @param fontsize_barplot_y_numbers fontsize of the text describing numeric barplot max & min values (number).\n#' @param max_digits_barplot_y_numbers Number of digits to round the numeric barplot max and min values to (number).\n#' @param fontsize_y_title fontsize of the y axis titles (a.k.a the data.frame column names) (number).\n#' @param y_axis_position Position of the y-axis (\"left\" or \"right\").\n#' @param numeric_plot_type Type of visualization for numeric data: \"bar\" or \"heatmap\".\n#' @param colours_default Default colors for categorical variables without a custom palette.\n#' @param colours_default_logical Colors for binary variables: a vector of three colors representing `TRUE`, `FALSE`, and `NA` respectively (character).\n#' @param colours_missing Color for missing (`NA`) values in categorical plots (string).\n#' @param na_marker Text used to mark `NA` values in numeric plots (string).\n#' @param na_marker_size Size of the text marker for `NA` values (number).\n#' @param na_marker_colour Color of the `NA` text marker (string).\n#' @param colours_heatmap_low Color for the lowest value in heatmaps (string).\n#' @param colours_heatmap_high Color for the highest value in heatmaps (string).\n#' @param transform_heatmap Transformation to apply before visualizing heatmap values (\"identity\", \"log10\", \"log2\").\n#' @param show_na_marker_categorical Show a marker for `NA` values on categorical tiles (flag).\n#' @param show_na_marker_heatmap Show a marker for `NA` values on heatmap tiles (flag).\n#' @param show_values_heatmap Display numerical values on heatmap tiles (flag).\n#' @param fontsize_values_heatmap Font size for heatmap values (number).\n#' @param legend_orientation_heatmap should legend orientation be \"horizontal\" or \"vertical\".\n#' @param width controls how much space is present between bars and tiles within each plot. Can be 0-1 where values of 1 makes bars/tiles take up 100% of available space (no gaps between bars).\n#' @param relative_height_numeric how many times taller should numeric plots be relative to categorical tile plots. Only taken into account if numeric_plot_type == \"bar\" (number)\n#' @param cli_header Text used for h1 header. Included so it can be tweaked by packages that use gg1d, so they can customise how the info messages appear.\n#' @param interactive_svg_width,interactive_svg_height width and height of the interactive graphic region (in inches). Only used when `interactive = TRUE`.\n#' @param colours_values_heatmap Color for heatmap values (string).\n#' @return A list of visualization parameters for `gg1d`.\n#' @export\n#' @inherit gg1d examples\ngg1d_options <- function(\n    # Default Colours\n    colours_default = c(\"#66C2A5\", \"#FC8D62\", \"#8DA0CB\", \"#E78AC3\", \"#A6D854\", \"#FFD92F\", \"#E5C494\"),\n    colours_default_logical = c(\"TRUE\" = \"#648fff\", \"FALSE\" = \"#dc267f\"),\n    colours_missing = \"grey90\",\n    # Legend\n    show_legend_titles = FALSE,\n    legend_title_position = c(\"top\", \"bottom\", \"left\", \"right\"),\n    legend_nrow = 4, legend_ncol = NULL,\n    legend_title_size = NULL, legend_text_size = NULL, legend_key_size = 0.3,\n    legend_orientation_heatmap = c(\"horizontal\", \"vertical\"),\n    show_legend = TRUE,\n    legend_position = c(\"right\", \"left\", \"bottom\", \"top\"),\n    # Missing Data\n    na_marker = \"!\", na_marker_size = 8, na_marker_colour = \"black\",\n    show_na_marker_categorical = FALSE,\n    show_na_marker_heatmap = FALSE,\n    # Heatmap\n    colours_heatmap_low = \"purple\",\n    colours_heatmap_high = \"seagreen\",\n    transform_heatmap = c(\"identity\", \"log10\", \"log2\"),\n    fontsize_values_heatmap = 3,\n    show_values_heatmap = FALSE,\n    colours_values_heatmap = \"white\",\n    # Global Paramaters\n    vertical_spacing = 0,\n    numeric_plot_type = c(\"bar\", \"heatmap\"),\n    y_axis_position = c(\"left\", \"right\"),\n    width = 0.9,\n    relative_height_numeric = 4,\n    cli_header = \"Running gg1d\",\n    # Interactivity\n    interactive_svg_width = NULL,\n    interactive_svg_height = NULL,\n    # Text\n    fontsize_barplot_y_numbers = 8,\n    max_digits_barplot_y_numbers = 3,\n    fontsize_y_title = 12,\n    beautify_text = TRUE) {\n  # Legend-related\n  assert_flag(show_legend)\n  assert_flag(show_legend_titles)\n  assert_number(legend_key_size)\n  if (!is.null(legend_nrow)) assert_number(legend_nrow)\n  if (!is.null(legend_ncol)) assert_number(legend_ncol)\n  if (!is.null(legend_title_size)) assert_number(legend_title_size)\n  if (!is.null(legend_ncol) & !is.null(legend_nrow)) {\n    cli::cli_warn(c(\"!\" = \"Both {.arg legend_ncol} and {.arg legend_nrow} were supplied. {.arg legend_nrow} will be ignored.  Explicitly set one of these arguments to NULL to avoid this warning message\"))\n    legend_nrow <- NULL\n  }\n\n  # Colors and styling\n  assert_string(colours_missing)\n  assert_string(colours_heatmap_low)\n  assert_string(colours_heatmap_high)\n  assert_string(colours_values_heatmap)\n  assert_equal(length(colours_default_logical), 2)\n  assert_names_include(colours_default_logical, c(\"TRUE\", \"FALSE\"))\n\n  # NA markers and visualization\n  assert_logical(show_na_marker_categorical)\n  assert_logical(show_na_marker_heatmap)\n  assert_logical(show_values_heatmap)\n  assert_string(na_marker_colour)\n\n  # Text and layout\n  assert_flag(beautify_text)\n  assert_number(vertical_spacing)\n  assert_number(fontsize_values_heatmap)\n  assert_number(relative_height_numeric)\n\n  # Argument matching (these check the allowed values for these parameters)\n  legend_position <- rlang::arg_match(legend_position)\n  legend_title_position <- rlang::arg_match(legend_title_position)\n  y_axis_position <- rlang::arg_match(y_axis_position)\n  numeric_plot_type <- rlang::arg_match(numeric_plot_type)\n  legend_orientation_heatmap <- rlang::arg_match(legend_orientation_heatmap)\n  transform_heatmap <- rlang::arg_match(transform_heatmap)\n\n  # Interactive\n  if (!is.null(interactive_svg_width)) {\n    assert_number(interactive_svg_width)\n  }\n  if (!is.null(interactive_svg_height)) {\n    assert_number(interactive_svg_height)\n  }\n\n  # Ignore relative_height_numeric if plot type is numeric\n  if (numeric_plot_type == \"heatmap\") relative_height_numeric <- 1\n\n  # Create options list\n  opts <- list(\n    show_legend = show_legend,\n    show_legend_titles = show_legend_titles,\n    legend_position = legend_position,\n    legend_title_position = legend_title_position,\n    legend_nrow = legend_nrow,\n    legend_ncol = legend_ncol,\n    legend_title_size = legend_title_size,\n    legend_text_size = legend_text_size,\n    legend_key_size = legend_key_size,\n    legend_orientation_heatmap = legend_orientation_heatmap,\n    beautify_text = beautify_text,\n    vertical_spacing = vertical_spacing,\n    fontsize_barplot_y_numbers = fontsize_barplot_y_numbers,\n    max_digits_barplot_y_numbers = max_digits_barplot_y_numbers,\n    fontsize_y_title = fontsize_y_title,\n    y_axis_position = y_axis_position,\n    numeric_plot_type = numeric_plot_type,\n    colours_default = colours_default,\n    colours_default_logical = colours_default_logical,\n    colours_missing = colours_missing,\n    cli_header = cli_header,\n    na_marker = na_marker,\n    na_marker_size = na_marker_size,\n    na_marker_colour = na_marker_colour,\n    colours_heatmap_low = colours_heatmap_low,\n    colours_heatmap_high = colours_heatmap_high,\n    transform_heatmap = transform_heatmap,\n    show_na_marker_categorical = show_na_marker_categorical,\n    show_na_marker_heatmap = show_na_marker_heatmap,\n    show_values_heatmap = show_values_heatmap,\n    fontsize_values_heatmap = fontsize_values_heatmap,\n    colours_values_heatmap = colours_values_heatmap,\n    relative_height_numeric = relative_height_numeric,\n    width = width,\n    interactive_svg_width = interactive_svg_width,\n    interactive_svg_height = interactive_svg_height\n  )\n\n  # Set class so we can check what is supplied to gg1d options argument was produced\n  # specifically by this function\n  class(opts) <- \"gg1d_options\"\n\n  return(opts)\n}\n","type":"text"},{"name":"ggnd.Rproj","content":"Version: 1.0\n\nRestoreWorkspace: No\nSaveWorkspace: No\nAlwaysSaveHistory: Default\n\nEnableCodeIndexing: Yes\nUseSpacesForTab: Yes\nNumSpacesForTab: 2\nEncoding: UTF-8\n\nRnwWeave: Sweave\nLaTeX: pdfLaTeX\n\nAutoAppendNewline: Yes\nStripTrailingWhitespace: Yes\nLineEndingConversion: Posix\n","type":"text"},{"name":"utils.R","content":"#' Format error messages as html\n#'\n#' @description Format error messages as html\n#'\n#' @return The return value, if any, from executing the utility.\n#'\n#' @noRd\nerr2html <- function(err){\n  tags$code(HTML(cli::ansi_html(as.character(err))))\n}\n","type":"text"}]
